<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode题解：预测赢家</title>
    <url>/2020/09/01/Code486/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="预测赢家"><a href="#预测赢家" class="headerlink" title="预测赢家"></a>预测赢家</h1><blockquote>
<p><a href="https://leetcode-cn.com/problems/predict-the-winner/">486.预测赢家</a></p>
<p>​        给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p>
<p>​        给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p>
</blockquote>
<p>​        拿到题目，第一瞬间想到的就是贪心，每次都拿左右两端出现的最大值，但仔细看看，便发现并不成立，例如[1, 5, 233, 7]，想赢必须先拿1。贪心算法所作的贪心选择可以依赖于以往所作过的选择，但决不依赖于将来所作的选择，也不依赖于子问题的解。但这题是需要依赖子问题的解的，于是我把目光投到了动态规划。</p>
<p>​        当数组长度为偶数时，先手必赢，因为最终的两种路线先手都可以走。然后，当数组只有一个数时，先手也必赢，并且两者分数的差即为nums[i]。于是，我们可以将dp数组表示为：<strong>在[i,j]区间内，当前要拿分数的玩家与后拿分数的玩家分数差的最大值</strong>（注意是当前要拿数的玩家，这个玩家不一定就是最开始的先手玩家）。在[i,j]区间内，我们不需要考虑之后怎么拿，只需要考虑这个区间的结果。当我们拿i时，另一个玩家只能在剩余的[i+1,j]区间内尽可能拿有利于自己的分数，这样子我们就可以推出状态转移方程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i][j] = Math.max(nums[i] - dp[i + <span class="number">1</span>][j], nums[j] - dp[i][j - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<p>最后，我们要求的即为dp[0][len-1]是否大于或等于0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果nums长度为偶数，则先手必赢。如[3,5,4,6,5,3]，如果先手从左开始则后手赢，但先手可以直接走后手赢的路线（即从右端开始），则先手赢</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dp[i][j]表示：在[i,j]区间内，当前的要拿数的玩家与后拿数的玩家分数差的最大值（注意是当前要拿数的玩家，这个玩家不一定就是最开始的先手玩家）</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length][nums.length];</span><br><span class="line">        <span class="comment">//当仅有一个数时，两者最大差值必为此数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i][i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//状态转移方程:dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])</span></span><br><span class="line">        <span class="comment">//很明显，i必须从右往左遍历，而j必须从左往右遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.max(nums[i] - dp[i + <span class="number">1</span>][j], nums[j] - dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][nums.length - <span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode题解</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Jsoup爬虫</title>
    <url>/2020/09/01/Jsoup%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Jsoup爬虫"><a href="#Jsoup爬虫" class="headerlink" title="Jsoup爬虫"></a>Jsoup爬虫</h1><p>[TOC]</p>
<img src= "/img/loading.gif" data-lazy-src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1583555021404.png" alt="1583555021404" style="zoom: 80%;" />

<p>（其实jsoup的connect功能已经能直接凭借网页的url提取html文档了，所以其实可以省略HttpClient，至于两者具体区别，论坛说法不一，多数人认为HttpClient相比jsoup的connect可以满足更高层次的需求）</p>
<h2 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h2><p>HttpClient 是Apache Jakarta Common 下的子项目，可以用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。 </p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>实现了所有 HTTP 的方法（GET、POST、PUT、HEAD、DELETE、HEAD、OPTIONS 等）</li>
<li>支持 HTTPS 协议</li>
<li>支持代理服务器（Nginx等）等</li>
<li>支持自动（跳转）转向</li>
</ul>
<h4 id="1、引入依赖"><a href="#1、引入依赖" class="headerlink" title="1、引入依赖"></a>1、引入依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<h4 id="2、简单使用（Get无参请求）"><a href="#2、简单使用（Get无参请求）" class="headerlink" title="2、简单使用（Get无参请求）"></a>2、简单使用（Get无参请求）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.ParseException;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.ClientProtocolException;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.config.RequestConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.CloseableHttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpGet;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.CloseableHttpClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.HttpClientBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.util.EntityUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientGet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获得Http客户端(可以理解为:你得先有一个浏览器;注意:实际上HttpClient与浏览器是不一样的)</span></span><br><span class="line">		CloseableHttpClient httpClient = HttpClientBuilder.create().build();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建Get请求</span></span><br><span class="line">		HttpGet httpGet = <span class="keyword">new</span> HttpGet(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">		<span class="comment">// 响应模型</span></span><br><span class="line">		CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 配置信息</span></span><br><span class="line">			RequestConfig requestConfig = RequestConfig.custom()</span><br><span class="line">					<span class="comment">// 设置连接超时时间(单位毫秒)</span></span><br><span class="line">					.setConnectTimeout(<span class="number">5000</span>)</span><br><span class="line">					<span class="comment">// 设置请求超时时间(单位毫秒)</span></span><br><span class="line">					.setConnectionRequestTimeout(<span class="number">5000</span>)</span><br><span class="line">					<span class="comment">// socket读写超时时间(单位毫秒)</span></span><br><span class="line">					.setSocketTimeout(<span class="number">5000</span>)</span><br><span class="line">					<span class="comment">// 设置是否允许重定向(默认为true)</span></span><br><span class="line">					.setRedirectsEnabled(<span class="keyword">true</span>).build();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 将上面的配置信息 运用到这个Get请求里</span></span><br><span class="line">			httpGet.setConfig(requestConfig);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 由客户端执行(发送)Get请求</span></span><br><span class="line">			response = httpClient.execute(httpGet);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 从响应模型中获取响应实体</span></span><br><span class="line">			HttpEntity responseEntity = response.getEntity();</span><br><span class="line">            <span class="comment">//对entity对象进行解码</span></span><br><span class="line">			String html=EntityUtils.toString(responseEntity, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;响应状态为:&quot;</span> + response.getStatusLine());</span><br><span class="line">			<span class="keyword">if</span> (responseEntity != <span class="keyword">null</span>) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;响应内容长度为:&quot;</span> + responseEntity.getContentLength());</span><br><span class="line">				System.out.println(<span class="string">&quot;响应内容为:&quot;</span> + html);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClientProtocolException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 释放资源</span></span><br><span class="line">				<span class="keyword">if</span> (httpClient != <span class="keyword">null</span>) &#123;</span><br><span class="line">					httpClient.close();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">					response.close();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Jsoup"><a href="#Jsoup" class="headerlink" title="Jsoup"></a>Jsoup</h2><p> jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 </p>
<h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>从一个URL，文件或字符串中解析HTML；</p>
<p>使用DOM或CSS选择器来查找、取出数据；</p>
<p>可操作HTML元素、属性、文本；</p>
<h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><h5 id="1、引入依赖-1"><a href="#1、引入依赖-1" class="headerlink" title="1、引入依赖"></a>1、引入依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.jsoup/jsoup --&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jsoup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsoup<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2、解析和遍历html文档"><a href="#2、解析和遍历html文档" class="headerlink" title="2、解析和遍历html文档"></a>2、解析和遍历html文档</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String html = <span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;First parse&lt;/title&gt;&lt;/head&gt;&quot;</span></span><br><span class="line">  + <span class="string">&quot;&lt;body&gt;&lt;p&gt;Parsed HTML into a doc.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line">Document doc = Jsoup.parse(html);</span><br></pre></td></tr></table></figure>

<h5 id="3、解析body片段"><a href="#3、解析body片段" class="headerlink" title="3、解析body片段"></a>3、解析body片段</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String html = <span class="string">&quot;&lt;div&gt;&lt;p&gt;Lorem ipsum.&lt;/p&gt;&quot;</span>;</span><br><span class="line">Document doc = Jsoup.parseBodyFragment(html);</span><br><span class="line">Element body = doc.body();</span><br></pre></td></tr></table></figure>

<h5 id="3、从一个URL加载一个Document"><a href="#3、从一个URL加载一个Document" class="headerlink" title="3、从一个URL加载一个Document"></a>3、从一个URL加载一个Document</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Document doc = Jsoup.connect(<span class="string">&quot;http://example.com/&quot;</span>).get();</span><br><span class="line">String title = doc.title();</span><br></pre></td></tr></table></figure>

<ul>
<li>只支持 Web URLs (http和https 协议) </li>
</ul>
<h5 id="4、从一个文件加载文档"><a href="#4、从一个文件加载文档" class="headerlink" title="4、从一个文件加载文档"></a>4、从一个文件加载文档</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File input = <span class="keyword">new</span> File(<span class="string">&quot;/tmp/input.html&quot;</span>);</span><br><span class="line">Document doc = Jsoup.parse(input, <span class="string">&quot;UTF-8&quot;</span>, <span class="string">&quot;http://example.com/&quot;</span>;);</span><br></pre></td></tr></table></figure>

<h4 id="数据抽取"><a href="#数据抽取" class="headerlink" title="数据抽取"></a>数据抽取</h4><h5 id="1、使用DOM方法来遍历一个文档"><a href="#1、使用DOM方法来遍历一个文档" class="headerlink" title="1、使用DOM方法来遍历一个文档"></a>1、使用DOM方法来遍历一个文档</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File input = <span class="keyword">new</span> File(<span class="string">&quot;/tmp/input.html&quot;</span>);</span><br><span class="line">Document doc = Jsoup.parse(input, <span class="string">&quot;UTF-8&quot;</span>, <span class="string">&quot;http://example.com/&quot;</span>);</span><br><span class="line"></span><br><span class="line">Element content = doc.getElementById(<span class="string">&quot;content&quot;</span>);</span><br><span class="line">Elements links = content.getElementsByTag(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Element link : links) &#123;</span><br><span class="line">  String linkHref = link.attr(<span class="string">&quot;href&quot;</span>);</span><br><span class="line">  String linkText = link.text();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找元素：</p>
<ul>
<li>getElementById(String id)</li>
<li><code>getElementsByTag(String tag)</code></li>
<li><code>getElementsByClass(String className)</code></li>
<li><code>getElementsByAttribute(String key)</code> (and related methods)</li>
<li>Element siblings: <code>siblingElements()</code>, <code>firstElementSibling()</code>, <code>lastElementSibling()</code>; <code>nextElementSibling()</code>, <code>previousElementSibling()</code></li>
<li>Graph: <code>parent()</code>, <code>children()</code>, <code>child(int index)</code></li>
</ul>
<p>元素数据：</p>
<ul>
<li><code>attr(String key)</code>获取属性<code>attr(String key, String value)</code>设置属性</li>
<li><code>attributes()</code>获取所有属性</li>
<li><code>id()</code>, <code>className()</code> and <code>classNames()</code></li>
<li><code>text()</code>获取文本内容<code>text(String value)</code> 设置文本内容</li>
<li><code>html()</code>获取元素内HTML<code>html(String value)</code>设置元素内的HTML内容</li>
<li><code>outerHtml()</code>获取元素外HTML内容</li>
<li><code>data()</code>获取数据内容（例如：script和style标签)</li>
<li><code>tag()</code> and <code>tagName()</code></li>
</ul>
<p>操作HTML和文本</p>
<ul>
<li><code>append(String html)</code>, <code>prepend(String html)</code></li>
<li><code>appendText(String text)</code>, <code>prependText(String text)</code></li>
<li><code>appendElement(String tagName)</code>, <code>prependElement(String tagName)</code></li>
<li><code>html(String value)</code></li>
</ul>
<h5 id="2、使用选择器语法来查找元素"><a href="#2、使用选择器语法来查找元素" class="headerlink" title="2、使用选择器语法来查找元素"></a>2、使用选择器语法来查找元素</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File input = <span class="keyword">new</span> File(<span class="string">&quot;/tmp/input.html&quot;</span>);</span><br><span class="line">Document doc = Jsoup.parse(input, <span class="string">&quot;UTF-8&quot;</span>, <span class="string">&quot;http://example.com/&quot;</span>);</span><br><span class="line"></span><br><span class="line">Elements links = doc.select(<span class="string">&quot;a[href]&quot;</span>); <span class="comment">//带有href属性的a元素</span></span><br><span class="line">Elements pngs = doc.select(<span class="string">&quot;img[src$=.png]&quot;</span>);</span><br><span class="line">  <span class="comment">//扩展名为.png的图片</span></span><br><span class="line"></span><br><span class="line">Element masthead = doc.select(<span class="string">&quot;div.masthead&quot;</span>).first();</span><br><span class="line">  <span class="comment">//class等于masthead的div标签</span></span><br><span class="line"></span><br><span class="line">Elements resultLinks = doc.select(<span class="string">&quot;h3.r &gt; a&quot;</span>); <span class="comment">//在h3元素之后的a元素</span></span><br></pre></td></tr></table></figure>

<p>jsoup elements对象支持类似于<a href="http://www.w3.org/TR/2009/PR-css3-selectors-20091215/">CSS</a> (或<a href="http://jquery.com/">jquery</a>)的选择器语法，来实现非常强大和灵活的查找功能。.</p>
<p>这个<code>select</code> 方法在<code>Document</code>, <code>Element</code>,或<code>Elements</code>对象中都可以使用。且是上下文相关的，因此可实现指定元素的过滤，或者链式选择访问。</p>
<p>Select方法将返回一个<code>Elements</code>集合，并提供一组方法来抽取和处理结果。</p>
<p>Selector选择器:</p>
<ul>
<li><code>tagname</code>: 通过标签查找元素，比如：<code>a</code></li>
<li><code>ns|tag</code>: 通过标签在命名空间查找元素，比如：可以用 <code>fb|name</code> 语法来查找 `` 元素</li>
<li><code>#id</code>: 通过ID查找元素，比如：<code>#logo</code></li>
<li><code>.class</code>: 通过class名称查找元素，比如：<code>.masthead</code></li>
<li><code>[attribute]</code>: 利用属性查找元素，比如：<code>[href]</code></li>
<li><code>[^attr]</code>: 利用属性名前缀来查找元素，比如：可以用<code>[^data-]</code> 来查找带有HTML5 Dataset属性的元素</li>
<li><code>[attr=value]</code>: 利用属性值来查找元素，比如：<code>[width=500]</code></li>
<li><code>[attr^=value]</code>, <code>[attr$=value]</code>, <code>[attr*=value]</code>: 利用匹配属性值开头、结尾或包含属性值来查找元素，比如：<code>[href*=/path/]</code></li>
<li><code>[attr~=regex]</code>: 利用属性值匹配正则表达式来查找元素，比如： <code>img[src~=(?i)\.(png|jpe?g)]</code></li>
<li><code>*</code>: 这个符号将匹配所有元素</li>
</ul>
<p>Selector选择器组合使用:</p>
<ul>
<li><code>el#id</code>: 元素+ID，比如： <code>div#logo</code></li>
<li><code>el.class</code>: 元素+class，比如： <code>div.masthead</code></li>
<li><code>el[attr]</code>: 元素+class，比如： <code>a[href]</code></li>
<li>任意组合，比如：<code>a[href].highlight</code></li>
<li><code>ancestor child</code>: 查找某个元素下子元素，比如：可以用<code>.body p</code> 查找在”body”元素下的所有 <code>p</code>元素</li>
<li><code>parent &gt; child</code>: 查找某个父元素下的直接子元素，比如：可以用<code>div.content &gt; p</code> 查找 <code>p</code> 元素，也可以用<code>body &gt; *</code> 查找body标签下所有直接子元素</li>
<li><code>siblingA + siblingB</code>: 查找在A元素之前第一个同级元素B，比如：<code>div.head + div</code></li>
<li><code>siblingA ~ siblingX</code>: 查找A元素之前的同级X元素，比如：<code>h1 ~ p</code></li>
<li><code>el, el, el</code>:多个选择器组合，查找匹配任一选择器的唯一元素，例如：<code>div.masthead, div.logo</code></li>
</ul>
<p>伪选择器selectors:</p>
<ul>
<li><code>:lt(n)</code>: 查找哪些元素的同级索引值（它的位置在DOM树中是相对于它的父节点）小于n，比如：<code>td:lt(3)</code> 表示小于三列的元素</li>
<li><code>:gt(n)</code>:查找哪些元素的同级索引值大于<code>n``，比如</code>： <code>div p:gt(2)</code>表示哪些div中有包含2个以上的p元素</li>
<li><code>:eq(n)</code>: 查找哪些元素的同级索引值与<code>n</code>相等，比如：<code>form input:eq(1)</code>表示包含一个input标签的Form元素</li>
<li><code>:has(seletor)</code>: 查找匹配选择器包含元素的元素，比如：<code>div:has(p)</code>表示哪些div包含了p元素</li>
<li><code>:not(selector)</code>: 查找与选择器不匹配的元素，比如： <code>div:not(.logo)</code> 表示不包含 class=logo 元素的所有 div 列表</li>
<li><code>:contains(text)</code>: 查找包含给定文本的元素，搜索不区分大不写，比如： <code>p:contains(jsoup)</code></li>
<li><code>:containsOwn(text)</code>: 查找直接包含给定文本的元素</li>
<li><code>:matches(regex)</code>: 查找哪些元素的文本匹配指定的正则表达式，比如：<code>div:matches((?i)login)</code></li>
<li><code>:matchesOwn(regex)</code>: 查找自身包含文本匹配指定正则表达式的元素</li>
<li>注意：上述伪选择器索引是从0开始的，也就是说第一个元素索引值为0，第二个元素index为1等</li>
</ul>
<h5 id="3、从元素抽取属性、文本和HTML"><a href="#3、从元素抽取属性、文本和HTML" class="headerlink" title="3、从元素抽取属性、文本和HTML"></a>3、从元素抽取属性、文本和HTML</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String html = <span class="string">&quot;&lt;p&gt;An &lt;a href=&#x27;http://example.com/&#x27;&gt;&lt;b&gt;example&lt;/b&gt;&lt;/a&gt; link.&lt;/p&gt;&quot;</span>;</span><br><span class="line">Document doc = Jsoup.parse(html);<span class="comment">//解析HTML字符串返回一个Document实现</span></span><br><span class="line">Element link = doc.select(<span class="string">&quot;a&quot;</span>).first();<span class="comment">//查找第一个a元素</span></span><br><span class="line"></span><br><span class="line">String text = doc.body().text(); <span class="comment">// &quot;An example link&quot;//取得字符串中的文本</span></span><br><span class="line">String linkHref = link.attr(<span class="string">&quot;href&quot;</span>); <span class="comment">// &quot;http://example.com/&quot;//取得链接地址</span></span><br><span class="line">String linkText = link.text(); <span class="comment">// &quot;example&quot;&quot;//取得链接地址中的文本</span></span><br><span class="line"></span><br><span class="line">String linkOuterH = link.outerHtml(); </span><br><span class="line">    <span class="comment">// &quot;&lt;a href=&quot;http://example.com&quot;&gt;&lt;b&gt;example&lt;/b&gt;&lt;/a&gt;&quot;</span></span><br><span class="line">String linkInnerH = link.html(); <span class="comment">// &quot;&lt;b&gt;example&lt;/b&gt;&quot;//取得链接内的html内容</span></span><br></pre></td></tr></table></figure>

<p>基本方法：</p>
<ul>
<li>要取得一个属性的值，可以使用<code>Node.attr(String key)</code> 方法</li>
<li>对于一个元素中的文本，可以使用<code>Element.text()</code>方法</li>
<li>对于要取得元素或属性中的HTML内容，可以使用<code>Element.html()</code>, 或 <code>Node.outerHtml()</code>方法</li>
</ul>
<p>其他方法：</p>
<ul>
<li><code>Element.id()</code></li>
<li><code>Element.tagName()</code></li>
<li><code>Element.className()</code> and <code>Element.hasClass(String className)</code></li>
</ul>
<h5 id="4、处理URLs"><a href="#4、处理URLs" class="headerlink" title="4、处理URLs"></a>4、处理URLs</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Document doc = Jsoup.connect(<span class="string">&quot;http://www.open-open.com&quot;</span>).get();</span><br><span class="line"></span><br><span class="line">Element link = doc.select(<span class="string">&quot;a&quot;</span>).first();</span><br><span class="line">String relHref = link.attr(<span class="string">&quot;href&quot;</span>); <span class="comment">// == &quot;/&quot;</span></span><br><span class="line">String absHref = link.attr(<span class="string">&quot;abs:href&quot;</span>); <span class="comment">// &quot;http://www.open-open.com/&quot;</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>在HTML元素中，URLs经常写成相对于文档位置的相对路径： <code>...</code>. 当你使用 <code>Node.attr(String key)</code> 方法来取得a元素的href属性时，它将直接返回在HTML源码中指定定的值。</p>
<p>假如你需要取得一个绝对路径，需要在属性名前加 <code>abs:</code> 前缀。这样就可以返回包含根路径的URL地址<code>attr(&quot;abs:href&quot;)</code></p>
<p>因此，在解析HTML文档时，定义base URI非常重要。</p>
<p>如果你不想使用<code>abs:</code> 前缀，还有一个方法能够实现同样的功能 <code>Node.absUrl(String key)</code>。</p>
<h5 id="5、简单示例程序：打印微博热搜"><a href="#5、简单示例程序：打印微博热搜" class="headerlink" title="5、简单示例程序：打印微博热搜"></a>5、简单示例程序：打印微博热搜</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsoupWeiBoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//网址url，jsoup的connect只能检索http与https协议，所以开头必须加上http/https</span></span><br><span class="line">		String url=<span class="string">&quot;https://s.weibo.com/top/summary?Refer=top_hot&amp;topnav=1&amp;wvr=6&quot;</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//从url加载document</span></span><br><span class="line">			Document document=Jsoup.connect(url).get();</span><br><span class="line">			<span class="comment">//查找所有td标签下的a元素，就可以导出微博热搜</span></span><br><span class="line">			Elements elements=document.select(<span class="string">&quot;td&gt;a&quot;</span>);</span><br><span class="line">			<span class="comment">//用index代表热搜第几条，由于有一条置顶热搜，所以从0开始</span></span><br><span class="line">			<span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">			<span class="comment">//遍历elements</span></span><br><span class="line">			<span class="keyword">for</span> (Element element:elements) &#123;</span><br><span class="line">				System.out.print(index+<span class="string">&quot;:&quot;</span>);</span><br><span class="line">				<span class="comment">//打印a标签内内容：即该条微博热搜</span></span><br><span class="line">				System.out.println(element.text());</span><br><span class="line">				index++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//结束</span></span><br><span class="line">			System.out.println(<span class="string">&quot;爬取完毕&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据修改"><a href="#数据修改" class="headerlink" title="数据修改"></a>数据修改</h4><p>（本次作业基本使用不到，暂略）</p>
<p>参考网址：</p>
<p> <a href="https://www.open-open.com/jsoup/">https://www.open-open.com/jsoup/</a> </p>
<p> <a href="https://blog.csdn.net/justry_deng/article/details/81042379">https://blog.csdn.net/justry_deng/article/details/81042379</a> </p>
]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>PageHelper分页插件</title>
    <url>/2020/09/01/PageHelper%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="PageHelper分页插件"><a href="#PageHelper分页插件" class="headerlink" title="PageHelper分页插件"></a>PageHelper分页插件</h1><h2 id="1、引入"><a href="#1、引入" class="headerlink" title="1、引入"></a>1、引入</h2><p><strong>pom.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 分页插件 PageHelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>使用过高版本的PageHelper可能因为springboot依赖版本不够导致无法分页。</li>
<li>PageHelper.startPage(pageNum,pageSize);只对语句下第一个查询语句生效。</li>
</ul>
<p><strong>application.yml</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pagehelper:</span></span><br><span class="line">  <span class="attr">helper-dialect:</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">reasonable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">support-methods-arguments:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ol>
<li><code>helperDialect</code>：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置<code>helperDialect</code>属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值：<br><code>oracle</code>,<code>mysql</code>,<code>mariadb</code>,<code>sqlite</code>,<code>hsqldb</code>,<code>postgresql</code>,<code>db2</code>,<code>sqlserver</code>,<code>informix</code>,<code>h2</code>,<code>sqlserver2012</code>,<code>derby</code><br><strong>特别注意：</strong>使用 SqlServer2012 数据库时，需要手动指定为 <code>sqlserver2012</code>，否则会使用 SqlServer2005 的方式进行分页。<br>你也可以实现 <code>AbstractHelperDialect</code>，然后配置该属性为实现类的全限定名称即可使用自定义的实现方法。</li>
<li><code>offsetAsPageNum</code>：默认值为 <code>false</code>，该参数对使用 <code>RowBounds</code> 作为分页参数时有效。 当该参数设置为 <code>true</code> 时，会将 <code>RowBounds</code> 中的 <code>offset</code> 参数当成 <code>pageNum</code> 使用，可以用页码和页面大小两个参数进行分页。</li>
<li><code>rowBoundsWithCount</code>：默认值为<code>false</code>，该参数对使用 <code>RowBounds</code> 作为分页参数时有效。 当该参数设置为<code>true</code>时，使用 <code>RowBounds</code> 分页会进行 count 查询。</li>
<li><code>pageSizeZero</code>：默认值为 <code>false</code>，当该参数设置为 <code>true</code> 时，如果 <code>pageSize=0</code> 或者 <code>RowBounds.limit = 0</code> 就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是 <code>Page</code> 类型）。</li>
<li><code>reasonable</code>：分页合理化参数，默认值为<code>false</code>。当该参数设置为 <code>true</code> 时，<code>pageNum&lt;=0</code> 时会查询第一页， <code>pageNum&gt;pages</code>（超过总数时），会查询最后一页。默认<code>false</code> 时，直接根据参数进行查询。</li>
<li><code>params</code>：为了支持<code>startPage(Object params)</code>方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值， 可以配置 <code>pageNum,pageSize,count,pageSizeZero,reasonable</code>，不配置映射的用默认值， 默认值为<code>pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero</code>。</li>
<li><code>supportMethodsArguments</code>：支持通过 Mapper 接口参数来传递分页参数，默认值<code>false</code>，分页插件会从查询方法的参数值中，自动根据上面 <code>params</code> 配置的字段中取值，查找到合适的值时就会自动分页。 使用方法可以参考测试代码中的 <code>com.github.pagehelper.test.basic</code> 包下的 <code>ArgumentsMapTest</code> 和 <code>ArgumentsObjTest</code>。</li>
<li><code>autoRuntimeDialect</code>：默认值为 <code>false</code>。设置为 <code>true</code> 时，允许在运行时根据多数据源自动识别对应方言的分页 （不支持自动选择<code>sqlserver2012</code>，只能使用<code>sqlserver</code>），用法和注意事项参考下面的<strong>场景五</strong>。</li>
<li><code>closeConn</code>：默认值为 <code>true</code>。当使用运行时动态数据源或没有设置 <code>helperDialect</code> 属性自动获取数据库类型时，会自动获取一个数据库连接， 通过该属性来设置是否关闭获取的这个连接，默认<code>true</code>关闭，设置为 <code>false</code> 后，不会关闭获取的连接，这个参数的设置要根据自己选择的数据源来决定。</li>
</ol>
<p><strong>提示</strong>：当 <code>offsetAsPageNum=false</code> 的时候，由于 <code>PageNum</code> 问题，<code>RowBounds</code>查询的时候 <code>reasonable</code> 会强制为 <code>false</code>。使用 <code>PageHelper.startPage</code> 方法不受影响。</p>
<h2 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/findPage/&#123;pageNum&#125;/&#123;pageSize&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PageInfo&lt;Book&gt; <span class="title">findPage</span><span class="params">(<span class="meta">@PathVariable</span> (<span class="string">&quot;pageNum&quot;</span>)</span> <span class="keyword">int</span> pageNum,@<span class="title">PathVariable</span><span class="params">(<span class="string">&quot;pageSize&quot;</span>)</span> <span class="keyword">int</span> pageSize)</span>&#123;</span><br><span class="line">    PageHelper.startPage(pageNum,pageSize);</span><br><span class="line">    List&lt;Book&gt; list=bookRepository.findAll();</span><br><span class="line">    PageInfo&lt;Book&gt; pageInfo=<span class="keyword">new</span> PageInfo&lt;Book&gt;(list);</span><br><span class="line">    <span class="keyword">return</span> pageInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pageInfo返回数据：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="attr">&quot;list&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;auther&quot;</span>: <span class="string">&quot;b&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;f&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;auther&quot;</span>: <span class="string">&quot;g&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;java&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;auther&quot;</span>: <span class="string">&quot;张三&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;python&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;auther&quot;</span>: <span class="string">&quot;hxd&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;dsfsa&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;auther&quot;</span>: <span class="string">&quot;safsa&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="number">6</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;dd&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;auther&quot;</span>: <span class="string">&quot;dfs&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="number">7</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;7&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;auther&quot;</span>: <span class="string">&quot;7&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="number">8</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;8&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;auther&quot;</span>: <span class="string">&quot;8&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="number">9</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;对算法&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;auther&quot;</span>: <span class="string">&quot;d的萨芬&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;算法&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;auther&quot;</span>: <span class="string">&quot;汉化&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;pageNum&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;pageSize&quot;</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">&quot;size&quot;</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">&quot;startRow&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;endRow&quot;</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">&quot;pages&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">&quot;prePage&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;nextPage&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;isFirstPage&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;isLastPage&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;hasPreviousPage&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;hasNextPage&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;navigatePages&quot;</span>: <span class="number">8</span>,</span><br><span class="line">    <span class="attr">&quot;navigatepageNums&quot;</span>: [</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="number">2</span>,</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;navigateFirstPage&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;navigateLastPage&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">&quot;lastPage&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">&quot;firstPage&quot;</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>分页</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro简单使用</title>
    <url>/2020/09/01/Shiro/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Shiro简单使用"><a href="#Shiro简单使用" class="headerlink" title="Shiro简单使用"></a>Shiro简单使用</h1><p>什么是 Shiro</p>
<p>官网：<a href="http://shiro.apache.org/">http://shiro.apache.org/</a></p>
<p>是一款主流的 Java 安全框架，不依赖任何容器，可以运行在 Java SE 和 Java EE 项目中，它的主要作用是对访问系统的用户进行身份认证、授权、会话管理、加密等操作。</p>
<p>Shiro 就是用来解决安全管理的系统化框架。</p>
<h1 id="Shiro-核心组件"><a href="#Shiro-核心组件" class="headerlink" title="Shiro 核心组件"></a>Shiro 核心组件</h1><p>用户、角色、权限</p>
<p>会给角色赋予权限，给用户赋予角色</p>
<p>1、UsernamePasswordToken，Shiro 用来封装用户登录信息，使用用户的登录信息来创建令牌 Token。</p>
<p>2、SecurityManager，Shiro 的核心部分，负责安全认证和授权。</p>
<p>3、Suject，Shiro 的一个抽象概念，包含了用户信息。</p>
<p>4、Realm，开发者自定义的模块，根据项目的需求，验证和授权的逻辑全部写在 Realm 中。</p>
<p>5、AuthenticationInfo，用户的角色信息集合，认证时使用。</p>
<p>6、AuthorzationInfo，角色的权限信息集合，授权时使用。</p>
<p>7、DefaultWebSecurityManager，安全管理器，开发者自定义的 Realm 需要注入到 DefaultWebSecurityManager 进行管理才能生效。</p>
<p>8、ShiroFilterFactoryBean，过滤器工厂，Shiro 的基本运行机制是开发者定制规则，Shiro 去执行，具体的执行操作就是由 ShiroFilterFactoryBean 创建的一个个 Filter 对象来完成。</p>
<p>Shiro 的运行机制如下图所示。</p>
<p><img src= "/img/loading.gif" data-lazy-src="http://img.reainyday.top/image-20200701054152169.png" alt="image-20200701054152169"></p>
<h1 id="Spring-Boot-整合-Shiro"><a href="#Spring-Boot-整合-Shiro" class="headerlink" title="Spring Boot 整合 Shiro"></a>Spring Boot 整合 Shiro</h1><p>1、创建 Spring Boot 应用，集成 Shiro 及相关组件，pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1.tmp<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、自定义 Shiro 过滤器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccoutRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> principalCollection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authenticationToken</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AuthenticationException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;</span><br><span class="line">        Account account = accountService.findByUsername(token.getUsername());</span><br><span class="line">        <span class="keyword">if</span>(account != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(account,account.getPassword(),getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilterFactoryBean</span><span class="params">(<span class="meta">@Qualifier(&quot;securityManager&quot;)</span> DefaultWebSecurityManager securityManager)</span></span>&#123;</span><br><span class="line">        ShiroFilterFactoryBean factoryBean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        factoryBean.setSecurityManager(securityManager);</span><br><span class="line">        <span class="keyword">return</span> factoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultWebSecurityManager <span class="title">securityManager</span><span class="params">(<span class="meta">@Qualifier(&quot;accoutRealm&quot;)</span> AccoutRealm accoutRealm)</span></span>&#123;</span><br><span class="line">        DefaultWebSecurityManager manager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        manager.setRealm(accoutRealm);</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccoutRealm <span class="title">accoutRealm</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AccoutRealm();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写认证和授权规则：</p>
<blockquote>
<p>认证过滤器</p>
</blockquote>
<p>anon：无需认证。</p>
<p>authc：必须认证。</p>
<p>authcBasic：需要通过 HTTPBasic 认证。</p>
<p>user：不一定通过认证，只要曾经被 Shiro 记录即可，比如：记住我。</p>
<blockquote>
<p>授权过滤器</p>
</blockquote>
<p>perms：必须拥有某个权限才能访问。</p>
<p>roles：必须拥有某个角色才能访问。</p>
<p>port：请求的端口必须是指定值才可以。</p>
<p>rest：请求必须基于 RESTful，POST、PUT、GET、DELETE。</p>
<p>ssl：必须是安全的 URL 请求，协议 HTTPS。</p>
<p>创建 3 个页面，main.html、manage.html、administrator.html</p>
<p>访问权限如下：</p>
<p>1、必须登录才能访问 main.html</p>
<p>2、当前用户必须拥有 manage 授权才能访问 manage.html</p>
<p>3、当前用户必须拥有 administrator 角色才能访问 administrator.html</p>
<blockquote>
<p>Shiro 整合 Thymeleaf</p>
</blockquote>
<p>1、pom.xml 引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.theborakompanioni<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-extras-shiro<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、配置类添加 ShiroDialect</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ShiroDialect <span class="title">shiroDialect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ShiroDialect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span> <span class="attr">xmlns:shiro</span>=<span class="string">&quot;http://www.thymeleaf.org/thymeleaf-extras-shiro&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;shortcut icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>index<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;session.account != null&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;session.account.username&#125;+&#x27;欢迎回来！&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/logout&quot;</span>&gt;</span>退出<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/main&quot;</span>&gt;</span>main<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">shiro:hasPermission</span>=<span class="string">&quot;manage&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;manage&quot;</span>&gt;</span>manage<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">shiro:hasRole</span>=<span class="string">&quot;administrator&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/administrator&quot;</span>&gt;</span>administrator<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>代码：</p>
<p>ShiroConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dreamin.shiro.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> at.pollux.thymeleaf.shiro.dialect.ShiroDialect;</span><br><span class="line"><span class="keyword">import</span> com.dreamin.shiro.realm.AccountRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.spring.web.ShiroFilterFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.web.mgt.DefaultWebSecurityManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilterFactoryBean</span><span class="params">(<span class="meta">@Qualifier(&quot;manager&quot;)</span> DefaultWebSecurityManager defaultWebSecurityManager)</span></span>&#123;</span><br><span class="line">        ShiroFilterFactoryBean shiroFilterFactoryBean=<span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager);</span><br><span class="line">        <span class="comment">//权限设置</span></span><br><span class="line">        Map&lt;String,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;/main&quot;</span>,<span class="string">&quot;authc&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;/manage&quot;</span>,<span class="string">&quot;perms[manage]&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;/adminstrator&quot;</span>,<span class="string">&quot;roles[adminstrator]&quot;</span>);</span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(map);</span><br><span class="line">        <span class="comment">//设置登录页面</span></span><br><span class="line">        shiroFilterFactoryBean.setLoginUrl(<span class="string">&quot;/login&quot;</span>);</span><br><span class="line">        <span class="comment">//设置未授权页面</span></span><br><span class="line">        shiroFilterFactoryBean.setUnauthorizedUrl(<span class="string">&quot;/unauth&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultWebSecurityManager <span class="title">manager</span><span class="params">(<span class="meta">@Qualifier(&quot;accountRealm&quot;)</span> AccountRealm accountRealm)</span></span>&#123;</span><br><span class="line">        DefaultWebSecurityManager manager=<span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        manager.setRealm(accountRealm);</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountRealm <span class="title">accountRealm</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AccountRealm();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroDialect <span class="title">shiroDialect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShiroDialect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>AccountRealm</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dreamin.shiro.realm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dreamin.shiro.entity.Account;</span><br><span class="line"><span class="keyword">import</span> com.dreamin.shiro.service.AccountService;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.SecurityUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authc.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.AuthorizationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.authz.SimpleAuthorizationInfo;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.realm.AuthenticatingRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.realm.AuthorizingRealm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.PrincipalCollection;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.subject.Subject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权（权限）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> principalCollection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前登录用户信息</span></span><br><span class="line">        Subject subject= SecurityUtils.getSubject();</span><br><span class="line">        Account account=(Account)subject.getPrincipal();</span><br><span class="line">        <span class="comment">//设置角色</span></span><br><span class="line">        Set&lt;String&gt; roles=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        roles.add(account.getRole());</span><br><span class="line">        SimpleAuthorizationInfo info=<span class="keyword">new</span> SimpleAuthorizationInfo(roles);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置权限</span></span><br><span class="line">        info.addStringPermission(account.getPerms());</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证（登录）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authenticationToken</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AuthenticationException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken;</span><br><span class="line">        Account account = accountService.findByUsername(token.getUsername());</span><br><span class="line">        <span class="keyword">if</span> (account != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(account, account.getPassword(), getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/08/26/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Typora快捷键</title>
    <url>/2020/09/01/Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Typora快捷键"><a href="#Typora快捷键" class="headerlink" title="Typora快捷键"></a>Typora快捷键</h1><ul>
<li><p>标题级别：Ctrl+数字（数字不能用小键盘）</p>
<p>标题级别升/降：Ctrl + “+” 、Ctrl + “-“</p>
</li>
<li><p>字体加粗：Ctrl + b</p>
<p>字体倾斜：Ctrl + i</p>
<p>下划线    ：Ctrl + u</p>
</li>
<li><p>无序列表：Ctrl + Shift + ] 或 - + 空格</p>
<p>有序列表：数字+ “.” + 空格</p>
</li>
<li><p>插入表格：Ctrl + t</p>
<p>插入图片：Ctrl + Shift + i</p>
<p>插入链接：Ctrl + k</p>
<p>插入目录：[toc] + Enter</p>
<p>插入引用：— + Enter 或 &gt; + 空格</p>
<p>插入代码块：Ctrl + Shift + k</p>
<p>插入分隔线：— + Enter</p>
</li>
<li><p>全屏切换：Fn + F11</p>
</li>
</ul>
<p>​        侧边栏   ：Ctrl + Shife + L</p>
<p>​        跳转首尾：Ctrl + home/end</p>
<p>​        向左缩进：Crtl + [</p>
<p>​        向右缩进：Ctrl + ]</p>
<ul>
<li><p>选中单词：Ctrl + d</p>
<p>选中一行：Ctrl + l</p>
</li>
</ul>
<p>​        搜索        ：Ctrl + f</p>
<p>​        替换         ：Ctrl + h</p>
]]></content>
      <categories>
        <category>Typora</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载机制</title>
    <url>/2020/09/01/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p><img src= "/img/loading.gif" data-lazy-src="https://upload-images.jianshu.io/upload_images/1900685-5b9f351d3bc5b208.png" alt="img"></p>
<ul>
<li>如图，一个类从被加载到虚拟机开始，到卸载出内存为止，他的生命周期经过了<strong>加载、验证、准备、解析、初始化、使用、卸载</strong>七个阶段。而类加载的全过程包括了加载、验证、准备、解析、初始化五个阶段。</li>
<li><strong>类加载器的启动</strong>：类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</li>
<li><strong>开始顺序：</strong>在类加载中，加载、验证、准备、初始化四个步骤的开始顺序是固定的，而解析阶段则不一定，他在某些时候可以在初始化之后再开始解析。</li>
</ul>
<h2 id="2、加载"><a href="#2、加载" class="headerlink" title="2、加载"></a>2、加载</h2><p><strong>过程</strong></p>
<ol>
<li>通过一个类的全限定名来获取其定义的二进制字节流</li>
<li>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区中这个类的访问入口。(注意这里的Class对象和.class文件是完全不同的概念)</li>
</ol>
<p><strong>待加载的.class文件来源：</strong></p>
<p>（1）本地磁盘</p>
<p>（2）网上加载.class文件（Applet）</p>
<p>（3）从数据库中</p>
<p>（4）压缩文件中（ZAR，jar等）</p>
<p>（5）从其他文件生成的（JSP应用）</p>
<p>​          ……</p>
<h2 id="3、验证"><a href="#3、验证" class="headerlink" title="3、验证"></a>3、验证</h2><p>因为.class文件可以由多种渠道得到，我们并不能保证它是由编译得到的，所以我们必须保证文件的准确性，拒绝不满足语义或者恶意的字节码流。</p>
<p>验证的主要作用就是确保被加载的类的正确性。也是连接阶段的第一步。说白了也就是我们加载好的.class文件不能对我们的虚拟机有危害，所以先检测验证一下。他主要是完成四个阶段的验证：</p>
<ol>
<li><strong>文件格式的验证</strong>：验证.class文件字节流是否符合class文件的格式的规范，并且能够被当前版本的虚拟机处理。这里面主要对魔数、主版本号、常量池等等的校验。<ol>
<li>魔数：每个Class文件的头四个字节，唯一作用在于确定这个文件是否为一个可以被虚拟机接受的Class文件，十六进制表示为0xCAFEBABE。</li>
<li>版本号：第五六字节为次版本号，七八字节为主版本号，标志能执行该CLASS文件的JDK版本，不过从JDK1.2之后到目前次版本号都未使用，固定为0。</li>
<li>常量池：主要存放两大常量，即字面量和符号引用。字面量就是比如说int a = 1; 这个1就是字面量。又比如String a = “abc”,这个abc就是字面量。 在java中，一个java类将会编译成一个class文件。在编译时，java类并不知道引用类的实际内存地址，因此只能使用符号引用来代替。比如org.simple.People类要引用org.simple.Tool类，在编译时People类并不知道Tool类的实际内存地址，因此只能使用符号org.simple.Tool(假设)来表示Tool类的地址。而在类装载器装载People类时，此时可以通过虚拟机获取Tool类 的实际内存地址，因此便可以既将符号org.simple.Tool替换为Tool类的实际内存地址，及直接引用地址。</li>
</ol>
</li>
<li><strong>元数据验证</strong>：主要是对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求，比如说验证这个类是不是有父类，类中的字段方法是不是和父类冲突等等。</li>
<li><strong>字节码验证</strong>：这是整个验证过程最复杂的阶段，主要是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在元数据验证阶段对数据类型做出验证后，这个阶段主要对类的方法做出分析，保证类的方法在运行时不会做出危害虚拟机安全的行为。</li>
<li><strong>符号引用验证</strong>：它是验证的最后一个阶段，发生在虚拟机将符号引用转化为直接引用的时候。主要是对类自身以外的信息进行校验。目的是确保解析动作能够完成。</li>
</ol>
<p>对整个类加载机制而言，验证阶段是一个很重要但是非必需的阶段，如果我们的代码能够确保没有问题，那么我们就没有必要去验证，毕竟验证需要花费一定的的时间。当然我们可以使用-Xverfity:none来关闭大部分的验证。</p>
<h2 id="4、准备"><a href="#4、准备" class="headerlink" title="4、准备"></a>4、准备</h2><p><strong>准备阶段主要为类变量分配内存并设置初始值</strong>。这些内存都在方法区分配。在这个阶段我们只需要注意两点就好了，也就是类变量和初始值两个关键词：</p>
<p>（1）类变量（static）会分配内存，但是实例变量不会，实例变量主要随着对象的实例化一块分配到java堆中，</p>
<p>（2）这里的初始值指的是数据类型默认值，而不是代码中被显示赋予的值。比如</p>
<p>public static int value = 1; //在这里准备阶段过后的value值为0，而不是1。赋值为1的动作在初始化阶段。</p>
<p>当然还有其他的默认值。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://pics2.baidu.com/feed/962bd40735fae6cdf616ed21e7a1f42043a70fe3.png?token=531148998856e5d92d0b437d9f9131b2&s=1AAA7423131A4DC8585DB1CB0300C0B1" alt="img"></p>
<p>注意，在上面value是被static所修饰的准备阶段之后是0，但是如果同时被final和static修饰准备阶段之后就是1了。我们可以理解为static final在编译器就将结果放入调用它的类的常量池中了。</p>
<h2 id="5、解析"><a href="#5、解析" class="headerlink" title="5、解析"></a>5、解析</h2><p>解析阶段主要是虚拟机将常量池中的符号引用转化为直接引用的过程。什么是符号应用和直接引用呢？</p>
<p><strong>符号引用</strong>：以一组符号来描述所引用的目标，可以是任何形式的字面量，只要是能无歧义的定位到目标就好，就好比在班级中，老师可以用张三来代表你，也可以用你的学号来代表你，但无论任何方式这些都只是一个代号（符号），这个代号指向你（符号引用）</p>
<p><strong>直接引用</strong>：直接引用是可以指向目标的指针、相对偏移量或者是一个能直接或间接定位到目标的句柄。和虚拟机实现的内存有关，不同的虚拟机直接引用一般不同。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p>
<h2 id="6、初始化"><a href="#6、初始化" class="headerlink" title="6、初始化"></a>6、初始化</h2><p>这是类加载机制的最后一步，在这个阶段，java程序代码才开始真正执行。我们知道，在准备阶段已经为类变量赋过一次值。在初始化阶端，程序员可以根据自己的需求来赋值了。一句话描述这个阶段就是执行类构造器&lt; clinit &gt;()方法的过程。</p>
<p>在初始化阶段，主要为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p>
<p>①声明类变量是指定初始值</p>
<p>②使用静态代码块为类变量指定初始值</p>
<p>JVM初始化步骤</p>
<p>1、假如这个类还没有被加载和连接，则程序先加载并连接该类</p>
<p>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类</p>
<p>3、假如类中有初始化语句，则系统依次执行这些初始化语句</p>
<p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p>
<p>创建类的实例，也就是new的方式访问某个类或接口的静态变量，或者对该静态变量赋值调用类的静态方法反射（如 Class.forName(“com.shengsiyuan.Test”)）初始化某个类的子类，则其父类也会被初始化Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类好了，到目前为止就是类加载机制的整个过程，但是还有一个重要的概念，那就是类加载器。在加载阶段其实我们提到过类加载器，说是在后面详细说，在这就好好地介绍一下类加载器。</p>
]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>类加载机制</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程梳理</title>
    <url>/2020/08/27/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java多线程梳理"><a href="#Java多线程梳理" class="headerlink" title="Java多线程梳理"></a>Java多线程梳理</h1><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><h3 id="1-1-进程与线程"><a href="#1-1-进程与线程" class="headerlink" title="1.1 进程与线程"></a>1.1 进程与线程</h3><p><strong>进程：</strong>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。</p>
<p><strong>线程：</strong>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</p>
<p><strong>二者关系：</strong></p>
<ol>
<li><p>线程是进程的一部分；</p>
<ol start="2">
<li>一个线程只能属于一个进程，而一个进程可以拥有一个到多个线程；</li>
</ol>
</li>
</ol>
<p><strong>二者区别：</strong></p>
<ol>
<li>根本区别：进程是资源分配的基本单位，而线程是程序执行的基本单位。</li>
<li>内存空间：进程拥有自己独立的资源空间，每启动一个进程，系统会为其分配内存空间，且不同进程直接内存空间不共享；而线程与CPU资源分配无关，多个线程共享同一进程内的资源，使用相同的内存地址。</li>
<li>使用开销：进程和线程是包含关系，多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。区别在于：<ol>
<li>多进程的创建和切换相比多线程而言开销更大，并且多进程之间的通信比多线程更慢；</li>
<li>但是多进程的稳定性要高于多线程，因为在多线程的情况下，一个进程的崩溃并不会影响到其他进程，而在多线程的情况下，任何一个线程崩溃会导致整个进程崩溃。</li>
</ol>
</li>
</ol>
<h3 id="1-2-并行和串行"><a href="#1-2-并行和串行" class="headerlink" title="1.2 并行和串行"></a>1.2 并行和串行</h3><ul>
<li>串行：下载多个文件，按照一定的顺序去进行下载的，也就是说，必须等下载完A之后才能开始下载B，它们在时间上是不可能发生重叠的。</li>
<li>并行：下载多个文件，开启多条线程，多个文件同时进行下载，这里是严格意义上的，在同一时刻发生的，并行在时间上是重叠的。</li>
</ul>
<h2 id="2、多线程实现"><a href="#2、多线程实现" class="headerlink" title="2、多线程实现"></a>2、多线程实现</h2><h3 id="2-1-实现方法"><a href="#2-1-实现方法" class="headerlink" title="2.1 实现方法"></a>2.1 实现方法</h3><p><strong>实现多线程的四种方法：</strong></p>
<ol>
<li><p>继承Thread类；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dreamin.threadtest;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承Thread类，重写run()方法，调用start开启线程</span></span><br><span class="line"><span class="comment">//线程开启不一定立即执行，由CPU调度执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//run方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">400</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在看代码...&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//main线程，主线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个线程对象</span></span><br><span class="line">        ThreadTest1 threadTest1=<span class="keyword">new</span> ThreadTest1();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用start方法开启线程</span></span><br><span class="line">        threadTest1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在学习多线程...&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现Runnable接口；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dreamin.threadtest;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实Runnable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//run方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">400</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在看代码...&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadTest2 threadTest2=<span class="keyword">new</span> ThreadTest2();</span><br><span class="line">        <span class="comment">//创建线程对象，通过线程对象来开启我们的线程，代理</span></span><br><span class="line">        <span class="keyword">new</span> Thread(threadTest2).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在学习多线程...&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>实现Callable接口；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            FutureTask&lt;Integer&gt; ft=<span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> MyThread());</span><br><span class="line">            <span class="keyword">new</span> Thread(ft,String.valueOf(i)).start();</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            System.out.println(ft.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;运行中...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程池；</p>
<ul>
<li>通过ExecutorService实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService threadpool= Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            threadpool.execute(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t线程开始运行&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadpool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Executors来实现线程池常用的有newSingleThreadExecutor、newCachedThreadPool、newFixedThreadPool三种实现方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//newFixedThreadPool</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line"><span class="comment">//newCachedThreadPool</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line"><span class="comment">//newSingleThreadExecutor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));    </span><br></pre></td></tr></table></figure>

<p>除去基本的五个参数的构造方法外，ThreadPoolExecutor类还拥有一个七个参数的构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         threadFactory, defaultHandler);</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>corePoolSize</strong>：线程池中的常驻核心线程数。</li>
<li><strong>maximumPoolSize</strong>：线程池中能够容纳同时执行的最大线程数，此值必须大于等于1。</li>
<li><strong>keepAliveTime</strong>：多余的空闲线程的存活时间当前池中线程数量超过corePoolSize时，当空闲时间<br>达到keepAliveTime时，多余线程会被销毁直到只剩下corePoolSize个线程为止。</li>
<li><strong>unit</strong>： keepAliveTime的单位 。</li>
<li><strong>workQueue</strong>：任务队列，被提交但尚未被执行的任务。</li>
<li><strong>threadFactory</strong>：表示生成线程池中工作线程的线程工厂，用于创建线程，一般默认的即可。</li>
<li><strong>handler</strong>：拒绝策略，表示当队列满了，并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的runnable的策略。<ol>
<li>AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行.</li>
<li>CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不<br>会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。</li>
<li>DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加人队列中<br>尝试再次提交当前任务。</li>
<li>DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。<br>如果允许任务丢失，这是最好的一种策略。</li>
</ol>
</li>
</ol>
<p><strong>注意</strong>：</p>
<ul>
<li><p>在创建了线程池后，线程池中的线程数为零。</p>
</li>
<li><p>当调用execute()方法添加一个请求任务时，线程池会做出如下判断： </p>
<ol>
<li>如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务； </li>
<li>如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；</li>
<li>如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务； </li>
<li>如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</li>
</ol>
</li>
<li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行。</p>
</li>
<li><p>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。  所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。 </p>
</li>
</ul>
<p><strong>但是</strong>，在平时创建线程池中，我们实际上并不会采用上述的三种方式，而是通过构造方法自定义一个线程池。原因在于三者中都存在等待队列近乎无限或者最大线程数近乎无限的问题，这一点可以在源码上清晰的看到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService threadPool=<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>,<span class="number">5</span>,<span class="number">3L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>), Executors.defaultThreadFactory(),<span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t线程开始运行&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p><strong>区别:</strong></p>
<ol>
<li>对于继承Thread类和实现接口而言，由于Java中只允许单继承，如果通过继承Thread来实现多线程，就意味着该类无法再继承其他类，而Java支持一个类实现多个接口，避免了单继承的局限性，因此使用实现接口的方法要优于继承Thread类。其次，如果一个类继承Thread，则不适合资源共享。但是如果实现了Runnable接口的话，则很容易的实现资源共享。</li>
<li>对于实现Runnable接口和实现Callable接口而言，实现Callable是由返回值的，而实现Runnable接口并没有，也正因此，通过实现Callable接口可以更方便的知道该线程是否结束。</li>
</ol>
<h3 id="2-2-线程状态"><a href="#2-2-线程状态" class="headerlink" title="2.2 线程状态"></a>2.2 线程状态</h3><p>通过观察Thread的源码，很容易看出线程有<strong>NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED</strong>六大状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">     * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">     * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">     * such as processor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">     * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">     * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">     * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">     * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">     * following methods:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">     * perform a particular action.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">     * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">     * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">     * The thread has completed execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NEW</strong>： 新建状态，线程对象已经创建，但尚未启动;</p>
<p><strong>RUNNABLE</strong>:就绪状态，可运行状态，调用了线程的start方法，已经在java虚拟机中执行，等待获取操作系统资源如CPU，操作系统调度运行;</p>
<p><strong>BLOCKED</strong>:堵塞状态。线程等待锁的状态，等待获取锁进入同步块/方法或调用wait后重新进入需要竞争锁;</p>
<p><strong>WAITING</strong>：等待状态。等待另一个线程以执行特定的操作。调用以下方法进入等待状态。 Object.wait(), Thread.join(),LockSupport.park;</p>
<p><strong>TIMED_WAITING</strong>: 线程等待一段时间。调用带参数的Thread.sleep, objct.wait,Thread.join，LockSupport.parkNanos,LockSupport.parkUntil;</p>
<p><strong>TERMINATED</strong>:线程结束状态。</p>
<p><strong>WAITING</strong> 和<strong>BLOCKED</strong>区别：</p>
<ul>
<li>Thread如果是在等待获取锁，此时Thread的状态就是<strong>BLOCKED</strong>；</li>
<li>其他调用Object.wait,Thread.join,LockSupport.park等都是<strong>WAITING</strong> 或者<strong>TIMED_WAITING</strong>状态。</li>
</ul>
<h2 id="3、线程同步"><a href="#3、线程同步" class="headerlink" title="3、线程同步"></a>3、线程同步</h2><h3 id="3-1-多线程安全的三大特性"><a href="#3-1-多线程安全的三大特性" class="headerlink" title="3.1 多线程安全的三大特性"></a>3.1 多线程安全的三大特性</h3><p><strong>原子性</strong>：原子性是指一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p><strong>可见性</strong>：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。产生这样问题的原因是由于java线程通信是通过共享内存的方式进行通信的，而为了加快执行的速度，线程一般是不会直接操作内存的，而是操作缓存。</p>
<p><strong>有序性</strong>：有序性是指程序在执行的时候，程序的代码执行顺序和语句的顺序是一致的。产生这样问题的原因是由于指令重排的缘故。在Java内存模型中，为了加快程序的运行速度允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。（最简单的就是对于int a;int b;，可能因为指令重排的原因先执行int b;在单线程中并不会产生影响，但如果在多线程的环境下就可能出现问题）</p>
<h3 id="3-2-synchronized"><a href="#3-2-synchronized" class="headerlink" title="3.2 synchronized"></a>3.2 synchronized</h3><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。</p>
<p><strong>应用方式：</strong></p>
<p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p>
<ol>
<li>普通同步方法（实例方法），锁是当前实例对象 ，进入同步代码前要获得当前实例的锁；</li>
<li>静态同步方法，锁是当前类的class对象 ，进入同步代码前要获得当前类对象的锁；</li>
<li>同步方法块，锁是括号里面的对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li>
</ol>
<p><strong>注意</strong>: synchronized虽然实现了多线程的可见性和原子性，但并没有实现多线程的有序性，也就是并不能禁止指令重排。</p>
<h3 id="3-3-Lock锁"><a href="#3-3-Lock锁" class="headerlink" title="3.3 Lock锁"></a>3.3 Lock锁</h3><p>Lock锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">                ticket.sale();</span><br><span class="line">        &#125;, <span class="string">&quot;aa&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">                ticket.sale();</span><br><span class="line">        &#125;, <span class="string">&quot;bb&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">                ticket.sale();</span><br><span class="line">        &#125;, <span class="string">&quot;cc&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t卖出&quot;</span> + number-- + <span class="string">&quot;号票\t还剩&quot;</span> + number + <span class="string">&quot;张&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-4-volatile关键字"><a href="#3-4-volatile关键字" class="headerlink" title="3.4 volatile关键字"></a>3.4 volatile关键字</h3><p>volatile关键字保证了多线程的可见性和有序性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//    int number = 0;</span></span><br><span class="line">    AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTo60</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        number = <span class="number">60</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPlusPlus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        number++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByAtomic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可见性验证</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">see</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;启动&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            myData.addTo60();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;更新number为&quot;</span> + myData.number);</span><br><span class="line">        &#125;, <span class="string">&quot;AAA&quot;</span>).start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; mission is over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原子性验证</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">atomic</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    myData.addPlusPlus();</span><br><span class="line">                    myData.addByAtomic();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;当前number值为&quot;</span>+myData.number);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;当前atomicInteger值为&quot;</span>+myData.atomicInteger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        VolatileDemo volatileDemo=<span class="keyword">new</span> VolatileDemo();</span><br><span class="line">        volatileDemo.atomic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据结构和算法（一）</title>
    <url>/2020/09/01/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java数据结构和算法"><a href="#Java数据结构和算法" class="headerlink" title="Java数据结构和算法"></a>Java数据结构和算法</h1><p>包括：线性结构、非线性结构</p>
<p><strong>线性结构</strong></p>
<ul>
<li>线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系；</li>
<li>线性结构有两种不同的存储结构，即顺序存储结构(数组)和链式存储结构(链表)；<ul>
<li>顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的；</li>
<li>链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息。</li>
</ul>
</li>
<li>线性结构常见的有：数组、队列、链表和栈。</li>
</ul>
<p><strong>非线性结构</strong></p>
<ul>
<li>非线性结构包括：二维数组，多维数组，广义表，树结构，图结构。</li>
</ul>
<h2 id="1、稀疏数组"><a href="#1、稀疏数组" class="headerlink" title="1、稀疏数组"></a>1、稀疏数组</h2><ul>
<li><p>稀疏数组可以看做是普通数组的压缩，但是这里说的普通数组是值无效数据量远大于有效数据量的数组</p>
<ul>
<li>原数组中存在大量的无效数据，占据了大量的存储空间，真正有用的数据却少之又少；</li>
<li>压缩存储可以节省存储空间以避免资源的不必要的浪费，在数据序列化到磁盘时，压缩存储可以提高IO效率。</li>
</ul>
</li>
<li><p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">		arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">		arr[<span class="number">5</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">		arr[<span class="number">7</span>][<span class="number">7</span>] = <span class="number">9</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;原始数组：&quot;</span>);</span><br><span class="line">		print(arr);</span><br><span class="line">		System.out.println(<span class="string">&quot;稀疏数组：&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span>[][] sparseArr = changeToSparseArray(arr);</span><br><span class="line">		print(sparseArr);</span><br><span class="line">		save(sparseArr);</span><br><span class="line">		System.out.println(<span class="string">&quot;读取到的稀疏数组：&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span>[][] sparseArr2=find();		</span><br><span class="line">		print(sparseArr2);</span><br><span class="line">		System.out.println(<span class="string">&quot;转化为原始数组：&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span>[][] arr2=changeToArr(sparseArr2);</span><br><span class="line">		print(arr2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] changeToArr(<span class="keyword">int</span>[][] sparseArr) &#123;</span><br><span class="line">		<span class="keyword">int</span>[][] arr=<span class="keyword">new</span> <span class="keyword">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">			arr[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]]=sparseArr[i][<span class="number">2</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 原始转化为稀疏数组</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] changeToSparseArray(<span class="keyword">int</span>[][] arr) &#123;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">// 计数器</span></span><br><span class="line">		<span class="comment">// 遍历获得非零元素数</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (arr[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">					count++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 转换</span></span><br><span class="line">		<span class="keyword">int</span>[][] sparseArr = <span class="keyword">new</span> <span class="keyword">int</span>[count + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">		sparseArr[<span class="number">0</span>][<span class="number">0</span>] = arr.length;</span><br><span class="line">		sparseArr[<span class="number">0</span>][<span class="number">1</span>] = arr[<span class="number">0</span>].length;</span><br><span class="line">		sparseArr[<span class="number">0</span>][<span class="number">2</span>] = count;</span><br><span class="line">		count = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (arr[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">					sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">					sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">					sparseArr[count][<span class="number">2</span>] = arr[i][j];</span><br><span class="line">					count++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sparseArr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 存盘</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">int</span>[][] sparseArr)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		String path = <span class="string">&quot;D://save.txt&quot;</span>;</span><br><span class="line">		OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(path));</span><br><span class="line">		OutputStreamWriter outputStreamWriter = <span class="keyword">new</span> OutputStreamWriter(outputStream, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">		BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(outputStreamWriter);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sparseArr[i].length; j++) &#123;</span><br><span class="line">				bufferedWriter.write(sparseArr[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			bufferedWriter.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		bufferedWriter.close();</span><br><span class="line">		outputStreamWriter.close();</span><br><span class="line">		outputStream.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取磁盘</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] find()&#123;</span><br><span class="line">		String path = <span class="string">&quot;D://save.txt&quot;</span>;</span><br><span class="line">		<span class="keyword">int</span>[][] sparseArr=<span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span>(BufferedReader bufferedReader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(path),<span class="string">&quot;utf-8&quot;</span>))) &#123;</span><br><span class="line">			String line=bufferedReader.readLine();</span><br><span class="line">			<span class="keyword">int</span>[] tempArr=stringToInt(line);</span><br><span class="line">			sparseArr=<span class="keyword">new</span> <span class="keyword">int</span>[tempArr[<span class="number">2</span>]+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">			sparseArr[<span class="number">0</span>]=tempArr;</span><br><span class="line">			<span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>((line=bufferedReader.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				sparseArr[count]=stringToInt(line);</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sparseArr;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//字符串转化为数组</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] stringToInt(String str) &#123;</span><br><span class="line">		String []arr=str.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">		<span class="keyword">int</span>[] arr2=<span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			arr2[i]=Integer.parseInt(arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arr2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出二维数组</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[][] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">				System.out.printf(<span class="string">&quot;%d\t&quot;</span>, arr[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2、队列"><a href="#2、队列" class="headerlink" title="2、队列"></a>2、队列</h2><ul>
<li>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</li>
<li>队列是一种基于先进先出（FIFO）策略的集合类型。</li>
</ul>
<p>数组实现队列出现的问题：</p>
<ol>
<li>为什么用环形队列:如果不是环形队列：我们每次取出对头元素时，如果font指针向后挪动一位，取出的元素位置将无法再插入值；如果不移动font指针，就需要将整个数组向前挪动一位。前者造成了极大的空间浪费，后者又带来了过多的性能浪费。</li>
<li>为什么需要一个空节点：如果不留一个空节点，就无法直接判断队列是满还是空。n个元素的队列可能出现n+1种可能：如一个三个元素的队列font-rear：0-0（空）、0-1、0-2、0-0（满）,而如果引入一个空节点就正好有n+1个元素对应n+1种可能（rear指向下一个节点）：0-0（空）、0-1、0-2、0-3（满）。（当然，可以额外用一个flag值来判断是否为空）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyQueue myQueue = <span class="keyword">new</span> MyQueue(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show):显示队列\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;e(sxit):退出程序\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;a(add):添加数据到队列\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;g(get):从队列取出数据\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;h(head):查看队头的数据&quot;</span>);</span><br><span class="line">            String selection = input.next();</span><br><span class="line">            <span class="keyword">switch</span> (selection) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入一个数：&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> a = input.nextInt();</span><br><span class="line">                    myQueue.add(a);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;s&quot;</span>:</span><br><span class="line">                    myQueue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;h&quot;</span>:</span><br><span class="line">                    System.out.println(myQueue.headQueue());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;g&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;取出元素：&quot;</span>+myQueue.peek());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;e&quot;</span>:</span><br><span class="line">                    flag=<span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入正确格式的选择：&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] queueArray;</span><br><span class="line"></span><br><span class="line">    MyQueue(<span class="keyword">int</span> len) &#123;</span><br><span class="line">        maxSize = len;</span><br><span class="line">        queueArray = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rear == front) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否已满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((rear + <span class="number">1</span>) % maxSize == front) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//展示整个队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列为空，无法显示&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; front + size(); i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;a[%d]=%d\n&quot;</span>,i,queueArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回队列元素数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear - front + maxSize) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加队列元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列已满，无法添加&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queueArray[rear]=num;</span><br><span class="line">        rear=(rear+<span class="number">1</span>)%maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出队列头元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空，无法取出&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = queueArray[front];</span><br><span class="line">        front=(front+<span class="number">1</span>)%maxSize;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回队头元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列为空，无法返回&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queueArray[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、链表"><a href="#3、链表" class="headerlink" title="3、链表"></a>3、链表</h2><p>链表是有序的列表</p>
<h3 id="3-1-单向链表"><a href="#3-1-单向链表" class="headerlink" title="3.1 单向链表"></a>3.1 单向链表</h3><ul>
<li>内存存储示意图：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="http://img.reainyday.top/image-20200420111446374.png" alt="image-20200420111446374"></p>
<ul>
<li>逻辑结构示意图：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="http://img.reainyday.top/image-20200420111325757.png" alt="image-20200420111325757"></p>
<ul>
<li>链表是以结点的形式存储，是链式存储;</li>
<li>每个节点都包含data域、next域：指向下一个节点;</li>
<li>链表的各个节点不一定是连续存储；</li>
<li>链表分带头结点的链表和没有头节点的链表，根据实际需求确定使用。</li>
</ul>
<p>单链表实现出现的问题：</p>
<ol>
<li>为什么headNode不能改动，而需要每次定义一个temp实现功能：因为一旦headNode位置变化，就无法定位到单链表头节点，因为单链表通常情况下只能从头到尾单向遍历。</li>
<li>为什么插入需要找到插入位置的前一位而不是后一位：如果找的是后一位，虽然node.next可以指向后一位，但无法找出前一位指向node,原因同上。</li>
<li>单链表反转：先定义一个reserveNode的临时头结点，标记单链表第一个结点的next结点，然后取出第一个结点，让该结点指向reserveHeadNode的next结点，最后让reserveNode指向该结点，后续结点以此类推。最后，让headNode头节点指向reserveHeadNode的next结点。</li>
<li>单链表逆序输出：利用栈的先进后出原理。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dreamin.first;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLinkListTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLinkList myLinkList = <span class="keyword">new</span> MyLinkList();</span><br><span class="line">        System.out.println(<span class="string">&quot;单链表已创建&quot;</span>);</span><br><span class="line">        Node node1 = <span class="keyword">new</span> Node(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        Node node2 = <span class="keyword">new</span> Node(<span class="number">2</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        Node node3 = <span class="keyword">new</span> Node(<span class="number">3</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        myLinkList.addByOrder(node2);</span><br><span class="line">        myLinkList.addByOrder(node3);</span><br><span class="line">        myLinkList.addByOrder(node1);</span><br><span class="line">        myLinkList.addByOrder(node2);</span><br><span class="line">        myLinkList.show();</span><br><span class="line">        Node node4 = <span class="keyword">new</span> Node(<span class="number">3</span>, <span class="string">&quot;王小五&quot;</span>);</span><br><span class="line">        myLinkList.update(node4);</span><br><span class="line">        myLinkList.show();</span><br><span class="line">        myLinkList.delete(<span class="number">2</span>);</span><br><span class="line">        myLinkList.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;单链表节点数:&quot;</span> + nodeNum(myLinkList.getHeadNode()));</span><br><span class="line">        System.out.println(getValue(<span class="number">1</span>, myLinkList.getHeadNode()));</span><br><span class="line">        reserve(myLinkList.getHeadNode());</span><br><span class="line">        System.out.println(<span class="string">&quot;倒转后：&quot;</span>);</span><br><span class="line">        myLinkList.show();</span><br><span class="line">        System.out.println(<span class="string">&quot;逆序遍历：&quot;</span>);</span><br><span class="line">        reservePrint(myLinkList.getHeadNode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取单链表节点数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nodeNum</span><span class="params">(Node temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取单链表倒数第k个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> k, Node temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = nodeNum(temp);</span><br><span class="line">        <span class="keyword">int</span> index = length - k;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单链表反转</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reserve</span><span class="params">(Node headNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headNode==<span class="keyword">null</span>||headNode.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = headNode;</span><br><span class="line">        Node reserveHeadNode = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">        Node next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = temp.next;</span><br><span class="line">            temp.next = reserveHeadNode.next;</span><br><span class="line">            reserveHeadNode.next = temp;</span><br><span class="line">            temp = next;</span><br><span class="line">        &#125;</span><br><span class="line">        headNode.next = reserveHeadNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//逆序遍历打印输出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reservePrint</span><span class="params">(Node headNode)</span></span>&#123;</span><br><span class="line">        Stack&lt;Node&gt; nodeStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(headNode==<span class="keyword">null</span>||headNode.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空，无法输出&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp=headNode;</span><br><span class="line">        <span class="keyword">while</span> (temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            nodeStack.add(temp.next);</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!nodeStack.empty())&#123;</span><br><span class="line">            System.out.println(nodeStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建单链表类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkList</span> </span>&#123;</span><br><span class="line">    <span class="comment">//建立头节点</span></span><br><span class="line">    <span class="keyword">private</span> Node headNode = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="string">&quot;&quot;</span>);<span class="comment">//头节点不需要赋任何具有实际意义的值,也不需要改动位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getHeadNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> headNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过顺序添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node temp = headNode;<span class="comment">//获取头节点</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//待节点是否已经存在</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//为空时退出</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.id &gt; node.id) &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//找出待插入节点位置的前一个节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.id == node.id) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;<span class="comment">//判断节点是否已存在</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="keyword">false</span>) &#123;<span class="comment">//如果该节点不存在，执行插入操作</span></span><br><span class="line">            node.next = temp.next;</span><br><span class="line">            temp.next = node;</span><br><span class="line">            System.out.println(<span class="string">&quot;结点&quot;</span> + node.id + <span class="string">&quot;已插入&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;结点&quot;</span> + node.id + <span class="string">&quot;已存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改节点信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node temp = headNode;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//判断节点是否存在</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;对应节点不存在，无法修改&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.id == node.id) &#123;</span><br><span class="line">                temp.name = node.name;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除节点信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        Node temp = headNode;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//判断节点是否存在</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;对应节点不存在，无法删除&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.id == id) &#123;</span><br><span class="line">                temp.next = temp.next.next;</span><br><span class="line">                System.out.println(<span class="string">&quot;节点已删除&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node temp = headNode;</span><br><span class="line">        <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空，无法显示&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//到达链表末尾</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(temp.toString());</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, next=&quot;</span> + next +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-双向链表"><a href="#3-2-双向链表" class="headerlink" title="3.2 双向链表"></a>3.2 双向链表</h3><p>管理单向链表的缺点分析:</p>
<ul>
<li>单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找；</li>
<li>单向链表不能自我删除，需要靠辅助结点，而双向链表，则可以自我删除，所以前面我们单链表删除<br>时结点，总是找到temp,temp 是待删除结点的前一个节点。</li>
</ul>
<p>双向链表实现的问题：</p>
<ol>
<li>添加问题：添加可能出现两种情况，可能从中间插入，也可能从末尾插入，需要分情况操作；</li>
<li>删除问题：删除也可能出现两种情况，可能在中间删除，也可能从末尾删除，因为如果不分情况，末尾结点temp的next为空，你将temp.next.pre置为temp.next会报空指针异常。</li>
</ol>
<p>具体实现：（修改方式与但链表基本一致）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDoubleLinkListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyDoubleLinkList myDoubleLinkList=<span class="keyword">new</span> MyDoubleLinkList();</span><br><span class="line">        DoubleNode node1=<span class="keyword">new</span> DoubleNode(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        DoubleNode node2=<span class="keyword">new</span> DoubleNode(<span class="number">2</span>,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        DoubleNode node3=<span class="keyword">new</span> DoubleNode(<span class="number">3</span>,<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        myDoubleLinkList.add(node1);</span><br><span class="line">        myDoubleLinkList.add(node3);</span><br><span class="line">        myDoubleLinkList.add(node2);</span><br><span class="line">        System.out.println(<span class="string">&quot;添加后：&quot;</span>);</span><br><span class="line">        myDoubleLinkList.show();</span><br><span class="line">        myDoubleLinkList.peek(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后：&quot;</span>);</span><br><span class="line">        myDoubleLinkList.show();</span><br><span class="line">        myDoubleLinkList.peek(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后：&quot;</span>);</span><br><span class="line">        myDoubleLinkList.show();</span><br><span class="line">        myDoubleLinkList.peek(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后：&quot;</span>);</span><br><span class="line">        myDoubleLinkList.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDoubleLinkList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DoubleNode headNode=<span class="keyword">new</span> DoubleNode(<span class="number">0</span>,<span class="string">&quot;&quot;</span>);<span class="comment">//头结点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DoubleNode <span class="title">getHeadNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> headNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(DoubleNode node)</span></span>&#123;</span><br><span class="line">        DoubleNode temp=headNode;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;<span class="comment">//判断是不是在链表末端添加</span></span><br><span class="line">        <span class="keyword">while</span>(temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.id&gt;node.id)&#123;</span><br><span class="line">                flag=<span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp.next.id==node.id)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;该结点已存在，无法添加&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="keyword">false</span>)&#123;</span><br><span class="line">            node.next=temp.next;</span><br><span class="line">            node.pre=temp;</span><br><span class="line">            node.next.pre=node;</span><br><span class="line">            temp.next=node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp.next=node;</span><br><span class="line">            node.pre=temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">peek</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headNode==<span class="keyword">null</span>||headNode.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空，无法删除&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        DoubleNode temp=headNode.next;</span><br><span class="line">        <span class="keyword">while</span>(temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.id==id)&#123;</span><br><span class="line">                temp.pre.next=temp.next;</span><br><span class="line">                temp.next.pre=temp.pre;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.id==id)&#123;</span><br><span class="line">            temp.pre.next=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;该节点不存在，无法删除&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headNode==<span class="keyword">null</span>||headNode.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空，无法显示&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        DoubleNode temp=headNode;</span><br><span class="line">        <span class="keyword">while</span> (temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(temp.next.toString());</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> DoubleNode pre;</span><br><span class="line">    <span class="keyword">public</span> DoubleNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleNode</span><span class="params">(<span class="keyword">int</span> id,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DoubleNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-单向环形链表"><a href="#3-3-单向环形链表" class="headerlink" title="3.3 单向环形链表"></a>3.3 单向环形链表</h3><p><strong>Josephu(约瑟夫)问题</strong></p>
<p>实现可能出现的问题：</p>
<ol>
<li>对于toString方法的重写：不能重写next，否则会报java.lang.StackOverflowError异常，原因是当结点指向自身时会因为实例间的相互引用陷入死循环导致栈溢出。</li>
<li>为什么需要找出first结点前结点：因为当要取出单链表其中一个结点时必须让前一个结点指向后一个结点。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCircleLinkListTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCircleLinkList myCircleLinkList = <span class="keyword">new</span> MyCircleLinkList();</span><br><span class="line">        myCircleLinkList.add(<span class="number">125</span>);</span><br><span class="line">        myCircleLinkList.show();</span><br><span class="line">        myCircleLinkList.countBoy(<span class="number">10</span>,<span class="number">20</span>,<span class="number">125</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircleLinkList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Boy first = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加num个</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Boy temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            Boy boy = <span class="keyword">new</span> Boy(i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                first = boy;</span><br><span class="line">                first.setNext(first);</span><br><span class="line">                temp = first;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.setNext(boy);</span><br><span class="line">                boy.setNext(first);</span><br><span class="line">                temp = boy;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Boy temp = first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(temp.toString());</span><br><span class="line">            temp = temp.getNext();</span><br><span class="line">            <span class="keyword">if</span> (temp == first) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countBoy</span><span class="params">(<span class="keyword">int</span> startNo, <span class="keyword">int</span> moveTime, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span> || startNo &gt; num || moveTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;参数存在问题，无法执行&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Boy temp = first;<span class="comment">//保存当前结点前一位</span></span><br><span class="line">        Boy cur = first;<span class="comment">//保存当前节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到first结点前位置</span></span><br><span class="line">        <span class="keyword">while</span>(temp.getNext()!=first)&#123;</span><br><span class="line">            temp=temp.getNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找出开始结点前一位位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; startNo - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            temp = temp.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        cur = temp.getNext();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//找出移动moveTime-1次后结点位置</span></span><br><span class="line">            <span class="comment">//从自身开始报数，所以减一</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; moveTime - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                temp = temp.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = temp.getNext();</span><br><span class="line">            <span class="keyword">if</span>(temp==cur)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;出圈：&quot;</span>+cur.toString());</span><br><span class="line">            temp.setNext(cur.getNext());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最后一个结点：&quot;</span> + cur.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> Boy next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boy <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Boy next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Boy&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、栈"><a href="#4、栈" class="headerlink" title="4、栈"></a>4、栈</h2><p>（stack)</p>
<p><strong>基本概念</strong></p>
<ul>
<li>栈是一个先入后出(FILO-First In Last Out)的有序列表。</li>
<li>栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的<br>一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。</li>
<li>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元<br>素最先删除，最先放入的元素最后删除。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="http://img.reainyday.top/image-20200424091956701.png" alt="image-20200424091956701"></p>
<p><strong>应用场景</strong></p>
<ul>
<li>子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以<br>回到原来的程序中。</li>
<li>处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆<br>栈中。</li>
<li>表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。</li>
<li>二叉树的遍历。</li>
<li>图形的深度优先(depth 一first)搜索法。</li>
</ul>
<p><strong>数组模拟栈的实现</strong></p>
<ol>
<li>使用数组模拟。</li>
<li>定义一个top表示栈顶，初始化为-1。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用数组模拟栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStackTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayStack stack = <span class="keyword">new</span> ArrayStack(<span class="number">10</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line">        stack.push(<span class="number">4</span>);</span><br><span class="line">        stack.push(<span class="number">5</span>);</span><br><span class="line">        stack.show();</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//定义栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;<span class="comment">//top表示栈顶，初始化为-1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] stack;<span class="comment">//用数组模拟栈</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        stack=<span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈是否为满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈满，无法入栈&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack[++top] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈空，无法出栈&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack[top--];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;栈内元素为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.println(stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链表模拟栈的实现</strong></p>
<ul>
<li>使用单链表不需要担心栈满的问题。</li>
<li>当只有头结点时，此时栈便为空。</li>
<li>入栈：在单链表后添加一个新的结点。</li>
<li>出栈：让末尾结点前一个结点指向null。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkListStackTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkListStack stack = <span class="keyword">new</span> LinkListStack();</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line">        stack.push(<span class="number">4</span>);</span><br><span class="line">        stack.show();</span><br><span class="line">        System.out.println(stack.pop() + <span class="string">&quot;出栈&quot;</span>);</span><br><span class="line">        System.out.println(stack.pop() + <span class="string">&quot;出栈&quot;</span>);</span><br><span class="line"></span><br><span class="line">        stack.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkListStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结点类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义头节点</span></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head.next == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(num);</span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈为空，无法入栈&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="comment">//找到要删除的前一个结点也就是末尾结点的前一个结点</span></span><br><span class="line">        <span class="keyword">while</span> (temp.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = temp.next.value;</span><br><span class="line">        temp.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈的结点数（不包括head结点）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历栈，自栈顶向下输出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈为空，无法输出&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = head;</span><br><span class="line">        <span class="keyword">int</span> length = getLength();</span><br><span class="line">        <span class="keyword">int</span>[] numStack = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            numStack[i] = temp.next.value;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;栈内元素：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.println(numStack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用栈实现简单计算器</strong></p>
<ol>
<li><p>通过建立索引值遍历表达式</p>
</li>
<li><p>如果扫描到数字，直接入栈</p>
</li>
<li><p>如果扫描到符号：</p>
<ol>
<li>当前操作符优先级小于或等于栈内操作符时，弹出数字栈中的两个数字以及符号栈中一个符号，计算结果入栈，再判断当前操作符优先级是否小于或等于栈内操作符，循环直至当前操作符优先级高于栈内操作符。</li>
<li>将操作符入栈。</li>
</ol>
<p>原因：我们的想法是判断表达式的计算是否会被后面影响，不确定的情况下我们就先入栈，等到确定下一个操作符的出现不会影响前面的计算时（即下一个操作符优先级小于当前操作符），我们就将前面的出栈并计算。比如1*2-1，当出现减号时就代表前面可以计算。</p>
</li>
<li><p>当表达式扫描完成，就顺序弹出数字栈中两个数字及符号栈一个操作符并计算，计算结果放入数字栈，循环直至只剩下数字栈中一个数字，即为表达式结果。</p>
<p>原因：当表达式扫描完毕后，扫描完成的两个栈已经可以直接计算，就相当于第一遍是将从左到右可以直接计算的都计算完毕，而剩下的如1-2*2是扫描中无法计算的，就通过从右到左的计算方式，先计算2与2的乘积，再计算1-4。</p>
</li>
<li><p>弹出最后一个值并输出。</p>
</li>
</ol>
<p>（其实很多人应该是不理解第三步为什么要做循环，如果看的是尚硅谷视频应该会发现老师并没有做，依然似乎没问题，但其实如果不做循环，从左到右计算不彻底就可能出现一些问题，比如：1-2*2+100。从左到右彻底的话最后数字栈中是-3、100，但如果不彻底就会出现104 、1，看上去没问题，但计算结果后者却是-103，因为它先计算了100+4，再计算1-104。）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCalculatorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String expression = <span class="string">&quot;3-2*2+100&quot;</span>;</span><br><span class="line">        System.out.println(SimpleCalculator(expression));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">SimpleCalculator</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//数字栈</span></span><br><span class="line">        Stack&lt;Integer&gt; numberStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//符号栈</span></span><br><span class="line">        Stack&lt;Character&gt; symbolStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//符号数组</span></span><br><span class="line">        <span class="keyword">char</span>[] array = &#123;<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;/&#x27;</span>&#125;;</span><br><span class="line">        <span class="comment">//指示器</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断是否到底</span></span><br><span class="line">        <span class="keyword">while</span> (index != expression.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = expression.charAt(index);</span><br><span class="line">            <span class="comment">//判断是否为数字</span></span><br><span class="line">            <span class="keyword">if</span> (temp &gt; <span class="number">47</span> &amp;&amp; temp &lt; <span class="number">58</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//解决多位数问题</span></span><br><span class="line">                <span class="keyword">while</span> (index &lt; expression.length() &amp;&amp; expression.charAt(index) &gt; <span class="number">47</span> &amp;&amp; expression.charAt(index) &lt; <span class="number">58</span>) &#123;</span><br><span class="line">                    temp = expression.charAt(index);</span><br><span class="line">                    num = num * <span class="number">10</span> + temp - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                numberStack.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当为操作符时</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="string">&#x27;+&#x27;</span> || temp == <span class="string">&#x27;-&#x27;</span> || temp == <span class="string">&#x27;*&#x27;</span> || temp == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!symbolStack.isEmpty() &amp;&amp; priority(temp) &lt;= priority(symbolStack.peek())) &#123;</span><br><span class="line">                    <span class="keyword">int</span> a = numberStack.pop();</span><br><span class="line">                    <span class="keyword">int</span> b = numberStack.pop();</span><br><span class="line">                    <span class="keyword">char</span> c = symbolStack.pop();</span><br><span class="line">                    numberStack.add(calculator(a, b, c));</span><br><span class="line">                &#125;</span><br><span class="line">                symbolStack.add(temp);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!symbolStack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = numberStack.pop();</span><br><span class="line">            <span class="keyword">int</span> b = numberStack.pop();</span><br><span class="line">            <span class="keyword">char</span> c = symbolStack.pop();</span><br><span class="line">            numberStack.add(calculator(a, b, c));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numberStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;*&#x27;</span> || ch == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span> || ch == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;符号不正确&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculator</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> a + b;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> b - a;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> a * b;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> b / a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;符号不正确&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>逆波兰表达式（后缀表达式）</strong></p>
<ul>
<li>后缀表达式运算</li>
</ul>
<ol>
<li>初始化一个栈stack；</li>
<li>如果遍历到数字，直接入栈；</li>
<li>如果遍历到符号，将两个数字出栈并计算，计算结果入栈；</li>
<li>循环2-3两步；</li>
<li>返回唯一的栈顶元素。</li>
</ol>
<p>注意：第三步计算顺序：次顶元素（运算符）栈顶元素。</p>
<ul>
<li>中缀表达式转后缀表达式步骤</li>
</ul>
<ol>
<li><p>初始化两个栈：运算符栈s1 和储存中间结果的栈s2；</p>
</li>
<li><p>从左至右扫描中缀表达式；</p>
</li>
<li><p>遇到操作数时，将其压s2；</p>
</li>
<li><p>遇到运算符时，比较其与s1 栈顶运算符的优先级：</p>
<ol>
<li><p>如果s1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</p>
</li>
<li><p>否则，若优先级比栈顶运算符的高，也将运算符压入s1；</p>
</li>
<li><p>否则，将s1 栈顶的运算符弹出并压入到s2 中，再次转到(4-1)与s1 中新的栈顶运算符相比较；</p>
</li>
</ol>
</li>
<li><p>遇到括号时：</p>
<ol>
<li>如果是左括号“(”，则直接压入s1</li>
<li>如果是右括号“)”，则依次弹出s1 栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</li>
</ol>
</li>
<li><p>重复步骤2 至5，直到表达式的最右边</p>
</li>
<li><p>将s1 中剩余的运算符依次弹出并压入s2</p>
</li>
<li><p>依次弹出s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式。</p>
</li>
</ol>
<p>(对于这一套标准步骤，我们可以发现其实s2在整个过程中是没有出栈操作的，所以我们可以用字符串/数组来代替s2，这样实现的话也可以省去第八步得逆序过程)</p>
<p>其实概括出来就是：</p>
<ol>
<li>每当遇到数字就直接入s2</li>
<li>每当遇到运算符，与s1栈顶运算符比较优先级，优先级高则入s1栈，否则则将s1栈顶运算符入s2，继续比较直至s1栈空或者运算符优先级大于栈顶运算符,此时将运算符入s1栈。</li>
<li>每当遇到括号，左括号入栈，右括号出现则将左括号与右括号之间内容压入s2。</li>
<li>很显然，所有的步骤都是为了计算时优先级高的计算步骤能够先得到计算。</li>
</ol>
<p>代码：</p>
<p>（其实主要是理清楚步骤以及原理，代码直接看可能繁琐，但自己理清楚步骤后就可以将大问题化成一步步的小问题，这样写起来代码其实就不是很复杂了）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逆波兰表达式完成计算器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReversePolishNotationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String expression = <span class="string">&quot;100+2+3*20+12&quot;</span>;</span><br><span class="line">        String infixExpression = toInfixExpression(expression);</span><br><span class="line">        System.out.println(infixExpression);</span><br><span class="line">        System.out.println(reversePolishNotation(infixExpression));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中缀表达式转后缀表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">toInfixExpression</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;String&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        String s2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; expression.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = expression.charAt(index);</span><br><span class="line">            <span class="comment">//遍历到数字直接入s2，并index++</span></span><br><span class="line">            <span class="keyword">if</span> (temp &gt; <span class="number">47</span> &amp;&amp; temp &lt; <span class="number">58</span>) &#123;</span><br><span class="line">                String num = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">while</span> (index &lt; expression.length() &amp;&amp; expression.charAt(index) &gt; <span class="number">47</span> &amp;&amp; expression.charAt(index) &lt; <span class="number">58</span>) &#123;</span><br><span class="line">                    num += expression.charAt(index);</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                s2 += num + <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;+&#x27;</span> || temp == <span class="string">&#x27;-&#x27;</span> || temp == <span class="string">&#x27;*&#x27;</span> || temp == <span class="string">&#x27;/&#x27;</span> || temp == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">//遍历到运算符判断优先级</span></span><br><span class="line">                <span class="comment">//这里之所以加入(处理是因为左括号也会入栈，优先级比较可能出现运算符与括号比较</span></span><br><span class="line">                String symbol = temp + <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">while</span> (!s1.isEmpty() &amp;&amp; !symbol.equals(<span class="string">&quot;(&quot;</span>) &amp;&amp; priority(symbol) &lt;= priority(s1.peek())) &#123;</span><br><span class="line">                    s2 = s2 + s1.pop() + <span class="string">&quot; &quot;</span>;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                s1.add(symbol);</span><br><span class="line">                index++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">//对于右括号，我们只需要将栈中左括号以上运算符出s1栈到s2中即可</span></span><br><span class="line">                <span class="keyword">if</span> (!s1.peek().equals(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">                    s2 += s1.pop() + <span class="string">&quot; &quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//注意左括号本身也需要出栈</span></span><br><span class="line">                s1.pop();</span><br><span class="line">                index++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;请输入规范的字符串&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!s1.isEmpty()) &#123;</span><br><span class="line">            s2 += s1.pop() + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后缀表达式运算</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reversePolishNotation</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">        String[] elements = expression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String element : elements) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element.equals(<span class="string">&quot;+&quot;</span>) || element.equals(<span class="string">&quot;-&quot;</span>) || element.equals(<span class="string">&quot;*&quot;</span>) || element.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> a = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> b = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> result = calculator(a, b, element);</span><br><span class="line">                stack.add(result);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;</span><br><span class="line">                stack.add(Integer.parseInt(element));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;字符串不符合规范&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculator</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, String element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (element) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> a + b;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> b - a;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> a * b;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> b / a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;操作符有误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(String ch)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ch.equals(<span class="string">&quot;*&quot;</span>) || ch.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ch.equals(<span class="string">&quot;+&quot;</span>) || ch.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为如果遇见左括号需要直接将运算符入栈，所以将左括号优先级设为-1</span></span><br><span class="line">        <span class="keyword">if</span> (ch.equals(<span class="string">&quot;(&quot;</span>)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;符号不正确&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5、递归"><a href="#5、递归" class="headerlink" title="5、递归"></a>5、递归</h2><ul>
<li>简单的说: 递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问，同时可以让代码变得简洁。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="http://img.reainyday.top/image-20200427082051067.png" alt="image-20200427082051067"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过打印问题，回顾递归调用机制</span></span><br><span class="line">        <span class="comment">//test(4);</span></span><br><span class="line">        <span class="keyword">int</span> res = factorial(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;res=&quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            test(n - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="comment">//else &#123;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;n=&quot;</span> + n);</span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阶乘问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> factorial(n - <span class="number">1</span>) * n; <span class="comment">// 1 * 2 * 3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>递归需要遵守的重要规则：<ol>
<li>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)；</li>
<li>方法的局部变量是独立的，不会相互影响, 比如n 变量；</li>
<li>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据；</li>
<li>递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError；</li>
<li>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。</li>
</ol>
</li>
</ul>
<p>迷宫问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迷宫问题，求初始点到终点的一条通路（不一定是最小通路！）</span></span><br><span class="line"><span class="comment">//墙体设为1，路径设为0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    整体思路：</span></span><br><span class="line"><span class="comment">    1、每当我们经过一个点，将点标记为2，代表已走过；</span></span><br><span class="line"><span class="comment">    2、对于该点，我们依照下右上左的方向向后查找；</span></span><br><span class="line"><span class="comment">    3、如果该点所有路径都走不通，就返回false，回到上一个点处向后查找；</span></span><br><span class="line"><span class="comment">    4、当到达终点，即终点标记为2时，一层一层向上推出递归。</span></span><br><span class="line"><span class="comment">    递归思路：</span></span><br><span class="line"><span class="comment">    1、终止条件：终点处被遍历到或者已遍历完所有可遍历点；</span></span><br><span class="line"><span class="comment">    2、每层递归该做的事：判断该点是否是终点，标记该点已走过，下右上左策略判断是否可走；</span></span><br><span class="line"><span class="comment">    3、返回参数：返回该点四个方向是否有可到终点的通路。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiGong</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">3</span>, n = <span class="number">3</span>;<span class="comment">//终点位置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>][<span class="number">6</span>];<span class="comment">//迷宫初始化</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;<span class="comment">//起点位置</span></span><br><span class="line">        <span class="comment">//设置墙体</span></span><br><span class="line">        map[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">4</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">5</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        System.out.println(findWay(map, i, j));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; map.length; i1++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i2 = <span class="number">0</span>; i2 &lt; map[<span class="number">0</span>].length; i2++) &#123;</span><br><span class="line">                System.out.print(map[i1][i2] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">findWay</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当到达（6，5）时，表示已经找到通路</span></span><br><span class="line">        <span class="keyword">if</span> (map[m][n] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">            map[i][j] = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; map.length &amp;&amp; findWay(map, i + <span class="number">1</span>, j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j + <span class="number">1</span> &lt; map[<span class="number">0</span>].length &amp;&amp; findWay(map, i, j + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; findWay(map, i - <span class="number">1</span>, j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; findWay(map, i, j - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map[i][j] = <span class="number">0</span>;<span class="comment">//走不通后标记回0；</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>八皇后问题</strong></p>
<p>二维数组解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1、递归结束条件：当遍历完所有（即遍历完从第一行第八列开始的所有可能）自动结束</span></span><br><span class="line"><span class="comment">    2、每层递归流程：首先判断这一行是否为第八行，如果是，直接输出并返回，如果不是，在这一行寻找可以放置皇后的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightEmpress</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] board = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">8</span>];<span class="comment">//初始化棋盘</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        findWay(board, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findWay</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//已摆放完毕</span></span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;摆放方法&quot;</span>+k+<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            k++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">                    System.out.print(board[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(placeAble(board,num,i))&#123;</span><br><span class="line">                    board[num][i]=<span class="number">1</span>;</span><br><span class="line">                    findWay(board,num+<span class="number">1</span>);</span><br><span class="line">                    board[num][i]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否可以放置棋子</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">placeAble</span><span class="params">(<span class="keyword">int</span>[][] board,<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">            <span class="comment">//纵向是否存在棋子</span></span><br><span class="line">            <span class="keyword">if</span>(board[i][y]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                斜向是否存在棋子</span></span><br><span class="line"><span class="comment">                斜向表示：要么与该点和相等（左上-&gt;右下），要么与该点差相等（右上-&gt;左下）</span></span><br><span class="line"><span class="comment">                即：i+j==x+y||i-j==x-y   j=x+y-i||j=y-x+i</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span>((x+y-i&gt;=<span class="number">0</span>&amp;&amp;x+y-i&lt;<span class="number">8</span>&amp;&amp;board[i][x+y-i]==<span class="number">1</span>)||(y-x+i&gt;=<span class="number">0</span>&amp;&amp;y-x+i&lt;<span class="number">8</span>&amp;&amp;board[i][y-x+i]==<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一维数组解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用一维数组解决八皇后问题</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路分析：用数组小标来表示行号,用数组的值表示列数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightEmpress2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] col = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];<span class="comment">//初始化棋盘</span></span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        findWay(col, row);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findWay</span><span class="params">(<span class="keyword">int</span>[] col, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;方法&quot;</span> + num + <span class="string">&quot;:&quot;</span>);</span><br><span class="line">            num++;</span><br><span class="line">            print(col);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (check(col, row, i)) &#123;</span><br><span class="line">                    col[row] = i;</span><br><span class="line">                    findWay(col, row + <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        注意，这儿与二维数组不同，不需要让col[row]=0,</span></span><br><span class="line"><span class="comment">                        因为向后遍历赋值后col[row]会改变不需要</span></span><br><span class="line"><span class="comment">                        当然，你加上去也不会使结果受到影响</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否可以放置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] col, <span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (row + column == i + col[i] || row - column == i - col[i] || col[i] == column) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; col.length; i1++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i1 + <span class="number">1</span> == col[i]) &#123;</span><br><span class="line">                    System.out.print(<span class="number">1</span> + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.print(<span class="number">0</span> + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6、排序算法"><a href="#6、排序算法" class="headerlink" title="6、排序算法"></a>6、排序算法</h2><ul>
<li>内部排序：指将需要处理的所有数据都加载到内部存储器(内存)中进行排序。</li>
<li>外部排序法：数据量过大，无法全部加载到内存中，需要借助外部存储(文件等)进行排序。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="http://img.reainyday.top/%E5%B0%9A%E7%A1%85%E8%B0%B7_%E9%9F%A9%E9%A1%BA%E5%B9%B3_%E5%9B%BE%E8%A7%A3Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E5%B7%B2%E8%A7%A3%E9%94%81.jpg"></p>
<p><img src= "/img/loading.gif" data-lazy-src="http://img.reainyday.top/%E6%8E%92%E5%BA%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png"></p>
<h3 id="6-1-时间复杂度"><a href="#6-1-时间复杂度" class="headerlink" title="6.1 时间复杂度"></a>6.1 时间复杂度</h3><ol>
<li>时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。</li>
<li>时间复杂度：一般情况下，算法中的基本操作语句的重复执行次数是问题规模n 的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n 趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ( f(n) )，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。</li>
</ol>
<ul>
<li>T(n) 不同，但时间复杂度可能相同。如：T(n)=n²+7n+6 与T(n)=3n²+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n²)。</li>
<li>计算时间复杂度的方法：<ul>
<li>用常数1 代替运行时间中的所有加法常数T(n)=n²+7n+6 =&gt; T(n)=n²+7n+1</li>
<li>修改后的运行次数函数中，只保留最高阶项T(n)=n²+7n+1 =&gt; T(n) = n²</li>
<li>去除最高阶项的系数T(n) = n² =&gt; T(n) = n² =&gt; O(n²)</li>
</ul>
</li>
<li>常见时间复杂度：<ol>
<li>常数阶O(1)</li>
<li>对数阶O(log2n)</li>
<li>线性阶O(n)</li>
<li>线性对数阶O(nlog2n)</li>
<li>平方阶O(n^2)</li>
<li>立方阶O(n^3)</li>
<li>k 次方阶O(n^k)</li>
<li>指数阶O(2^n)</li>
</ol>
</li>
<li>Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n^2)＜Ο(n^3)＜ Ο(n^k) ＜Ο(2^n)</li>
<li>平均时间复杂度和最坏时间复杂度<ol>
<li>平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。</li>
<li>最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。</li>
</ol>
</li>
</ul>
<h3 id="6-2-冒泡排序（Bubble-Sort）"><a href="#6-2-冒泡排序（Bubble-Sort）" class="headerlink" title="6.2 冒泡排序（Bubble Sort）"></a>6.2 冒泡排序（Bubble Sort）</h3><ul>
<li>这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。</li>
<li>它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。</li>
<li>过程：<ol>
<li>设立两个指针，指向开始的两个元素，如果两者逆序，就交换两者位置。</li>
<li>两个指针同时向后移动，如果两个相邻元素逆序，就交换位置。</li>
<li>通过一遍循环，我们就可以确认固定最后一个元素。</li>
<li>重复上述步骤，直至所有元素被固定。</li>
</ol>
</li>
<li>时间复杂度：<ol>
<li>最坏时间复杂度（数组完全逆序）：O(n^2) </li>
<li>最好时间复杂度（数组完全顺序）：O(n) </li>
<li>平均时间复杂度：O(n^2)</li>
</ol>
</li>
<li>稳定性：稳定。因为两个相等元素不会交换位置。</li>
<li>优化：<ol>
<li>我们不必真的使用两个指针，因为指针是相邻的，后者位置为前者+1</li>
<li>如果在一次内部循环中，没有出现任何一次交换，就证明数组已经是顺序的，不需要继续交换，可以直接跳出外层循环。</li>
</ol>
</li>
<li>代码实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int[] array = &#123;1, 5, 8, 7, 6, 2&#125;;</span></span><br><span class="line"><span class="comment">//        int[] array = &#123;1, 2, 3, 4, 5, 6, 7, 9&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] sortedArray = bubbleSort(array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.print(sortedArray[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;  <span class="comment">//array.length - 1是因为当后面n-1个元素固定后第一个元素自然就固定好了</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;<span class="comment">//判断当前循环是否出现过交换</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123; <span class="comment">//array.length - i - 1是因为最后i个元素已经固定好，其次我们比较的是两个数，所以最后还得-1</span></span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = array[j];</span><br><span class="line">                    array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    flag=<span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//如果没有出现过交换，代表整个数组已经是顺序的，直接跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-3-选择排序（Selection-Sort）"><a href="#6-3-选择排序（Selection-Sort）" class="headerlink" title="6.3 选择排序（Selection Sort）"></a>6.3 选择排序（Selection Sort）</h3><ul>
<li>选择排序的原理就是每次循环都找出最小（大）的数放在最前面。</li>
<li>流程：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。</li>
<li>时间复杂度：O(n^2)</li>
<li>稳定性：不稳定。比如序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法。</li>
<li>选择排序相较于冒泡排序而言，选择排序的判断次数是固定的，而且必须遍历完所有可能性，而冒泡排序可以检测是否顺序中断排序，但选择排序的交换次数相比冒泡排序可以减少很多，而且交换所需要消耗的时间是比判断的时间是更多的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSortTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//        int[] array = &#123;1, 2, 3, 4, 5, 6, 7, 9&#125;;</span></span><br><span class="line"><span class="comment">//        int[] array = &#123;6, 5, 4, 2, 1, 0&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] sortedArray = selectionSort(array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.print(sortedArray[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectionSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">int</span> min, temp, key ;<span class="comment">//min存储当前循环最小值，key存储最小值的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            min = array[i];</span><br><span class="line">            key=i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &lt; min) &#123;</span><br><span class="line">                    min = array[j];</span><br><span class="line">                    key = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(key!=i)&#123;</span><br><span class="line">                temp = array[i];</span><br><span class="line">                array[i] = array[key];</span><br><span class="line">                array[key] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-4-插入排序（Insertion-Sort）"><a href="#6-4-插入排序（Insertion-Sort）" class="headerlink" title="6.4 插入排序（Insertion Sort）"></a>6.4 插入排序（Insertion Sort）</h3><ul>
<li>插入排序（Insertion Sorting）的基本思想是：把n 个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</li>
<li>示意图:</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://upload-images.jianshu.io/upload_images/11016594-150b6c462e3ed809.png"></p>
<ul>
<li>稳定性：稳定。插入排序如果碰到相等元素不会插入到相等元素的前面。</li>
<li>时间复杂度：O（n^2）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSortTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int[] array = &#123;1, 5, 8, 7, 6, 2&#125;;</span></span><br><span class="line"><span class="comment">//        int[] array = &#123;1, 2, 3, 4, 5, 6, 7, 9&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] sortedArray = InsertionSort(array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.print(sortedArray[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] InsertionSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt; array[i - <span class="number">1</span>]) &#123;<span class="comment">//如果第i个大于第i-1个,表明这个数字顺序是不需要调整的</span></span><br><span class="line">                <span class="keyword">int</span> temp=array[i];<span class="comment">//保存当前第i个位置的值</span></span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="keyword">for</span> (j = i; j &gt;<span class="number">0</span>&amp;&amp;array[j-<span class="number">1</span>]&gt;temp ; j--) &#123;</span><br><span class="line">                    array[j]=array[j-<span class="number">1</span>];<span class="comment">//将所有大于temp的值向后移</span></span><br><span class="line">                &#125;</span><br><span class="line">                array[j]=temp;<span class="comment">//插入temp</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-5-希尔排序-Shell’s-Sort"><a href="#6-5-希尔排序-Shell’s-Sort" class="headerlink" title="6.5 希尔排序(Shell’s Sort)"></a>6.5 希尔排序(Shell’s Sort)</h3><ul>
<li>希尔排序是希尔（Donald Shell）于1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。</li>
<li>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1 时，整个文件恰被分成一组，算法便终止。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="http://img.reainyday.top/xierpaixu.jpg"></p>
<p><img src= "/img/loading.gif" data-lazy-src="http://img.reainyday.top/xier1.jpg"></p>
<ul>
<li>希尔排序是基于插入排序的一种算法， 在此算法基础之上增加了一个新的特性，提高了效率。希尔排序的时间的时间复杂度为O（n^3/2)希尔排序时间复杂度的下界是n*log2n。希尔排序没有快速排序算法快 O(n(logn))，因此中等大小规模表现良好，对规模非常大的数据排序不是最优选择。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellsSortTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int[] array = &#123;1, 5, 5, 7, 6, 2&#125;;</span></span><br><span class="line"><span class="comment">//        int[] array = &#123;1, 2, 3, 4, 5, 6, 7, 9&#125;;</span></span><br><span class="line"><span class="comment">//        int[] array=&#123;8,9,1,7,2,3,5,4,6,0&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] sortedArray = ShellsSort(array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.print(sortedArray[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ShellsSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="comment">// 增量gap, 并逐步的缩小增量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap=array.length/<span class="number">2</span>; gap &gt;<span class="number">0</span> ; gap/=<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 从第gap 个元素，逐个对其所在的数组进行直接插入排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; array.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j=i;</span><br><span class="line">                temp=array[i];</span><br><span class="line">                <span class="keyword">if</span>(temp&lt;array[j-gap])&#123;</span><br><span class="line">                    <span class="keyword">while</span> (j-gap&gt;=<span class="number">0</span>&amp;&amp;array[j-gap]&gt;temp)&#123;</span><br><span class="line">                        array[j]=array[j-gap];</span><br><span class="line">                        j-=gap;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                array[j]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-6-快速排序-Quicksort"><a href="#6-6-快速排序-Quicksort" class="headerlink" title="6.6 快速排序(Quicksort)"></a>6.6 快速排序(Quicksort)</h3><ul>
<li>快速排序（Quicksort）是对冒泡排序的一种改进。</li>
<li>基本思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</li>
<li>基本流程：<ol>
<li>首先创建left、right两个指针，和一个基准数（不同方法选择的基准数位置不同）</li>
<li>将比基准数小的放在基准数左边，比基准数大的放在基准数右边（不要求顺序）</li>
<li>通过递归向左右执行1、2两步，直到left和right刚进入一层递归就已经相等，完成排序。</li>
</ol>
</li>
</ul>
<p><strong>挖坑法划分：</strong><a href="https://blog.csdn.net/morewindows/article/details/6684558%EF%BC%88%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2%EF%BC%89">https://blog.csdn.net/morewindows/article/details/6684558（参考博客）</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSortTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>,<span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//        int[] array = &#123;8, 2, 3, 4, 5, 6, 7, 9&#125;;</span></span><br><span class="line"><span class="comment">//        int[] array = &#123;6, 5, 4, 2, 1, 0&#125;;</span></span><br><span class="line"><span class="comment">//        int[] array = &#123;5, 6, 3, 1, 8, 7, 99&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] sortedArray = quickSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.print(sortedArray[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        挖坑法进行一次划分：</span></span><br><span class="line"><span class="comment">        1、通过将基准值作为坑，先向右找到小于基准值的数，将这个数填入坑中，而将这个数原来位置作为新坑</span></span><br><span class="line"><span class="comment">        2、然后，再向左找到小于基准值的数，将这个数填入新坑中，而将这个数原来位置作为新坑</span></span><br><span class="line"><span class="comment">        3、不断重复1、2两步，直至left==right，将基准值填入最后的坑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] array, <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = l;<span class="comment">//左指针确保left左边的数都小于基准值</span></span><br><span class="line">            <span class="keyword">int</span> right = r;<span class="comment">//右指针确保right右边的数都大于基准值</span></span><br><span class="line">            <span class="keyword">int</span> temp = array[left];<span class="comment">//保存基准值，并挖坑</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="comment">//从右向左找到第一个小于基准数的数</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; array[right] &gt;= temp) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                    array[left++] = array[right];<span class="comment">//填坑，并将array[right]作为新的坑</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//从左向右找到第一个大于基准数的数</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; array[left] &lt;= temp) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                    array[right--] = array[left];<span class="comment">//填坑，并将array[left]作为新的坑</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            array[right] = temp;<span class="comment">//当left和right相等时，填入基准值</span></span><br><span class="line">            quickSort(array, l, right - <span class="number">1</span>);<span class="comment">//向左重复</span></span><br><span class="line">            quickSort(array, left + <span class="number">1</span>, r);<span class="comment">//向右重复</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>交换法：</strong>逻辑更简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSortTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>,<span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//        int[] arr = &#123;1, 3, 5,5,7, 6, 2,2&#125;;</span></span><br><span class="line"><span class="comment">//        int[] arr = &#123;-9,78,0,23,-567,70, -1,900, 4561&#125;;</span></span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span> arr[],<span class="keyword">int</span> start,<span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[start];</span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">int</span> j = end;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j) &#123;</span><br><span class="line">            <span class="keyword">while</span> ((i&lt;j)&amp;&amp;(arr[j]&gt;pivot)) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ((i&lt;j)&amp;&amp;(arr[i]&lt;pivot)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((arr[i]==arr[j])&amp;&amp;(i&lt;j)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i-<span class="number">1</span>&gt;start) arr=quickSort(arr,start,i-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (j+<span class="number">1</span>&lt;end) arr=quickSort(arr,j+<span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> (arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-7-归并排序（MERGE-SORT）"><a href="#6-7-归并排序（MERGE-SORT）" class="headerlink" title="6.7 归并排序（MERGE-SORT）"></a>6.7 归并排序（MERGE-SORT）</h3><ul>
<li>归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。归并排序是一种稳定的排序方法。</li>
<li>归并排序是一种稳定的排序方法。</li>
<li>时间复杂度：O(nlogn)</li>
</ul>
<p>图解：</p>
<p><img src= "/img/loading.gif" data-lazy-src="http://img.reainyday.top/guibing1.jpg"></p>
<p><img src= "/img/loading.gif" data-lazy-src="http://img.reainyday.top/guibing2.jpg" alt="guibing2"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int[] array = &#123;1, 5, 7, 6, 2&#125;;</span></span><br><span class="line"><span class="comment">//        int[] array = &#123;6, 5, 4, 2, 1, 0&#125;;</span></span><br><span class="line"><span class="comment">//        int[] array = &#123;5, 6, 3, 1, 8, 7, 99&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        mergeSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>, temp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.print(array[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            mergeSort(array, left, mid, temp);</span><br><span class="line">            mergeSort(array, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">            merge(array, left, right, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt;= array[j]) &#123;</span><br><span class="line">                temp[index++] = array[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[index++] = array[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            temp[index++] = array[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            temp[index++] = array[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            array[left++] = temp[index++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-8-基数排序（Radix-Sort）"><a href="#6-8-基数排序（Radix-Sort）" class="headerlink" title="6.8 基数排序（Radix Sort）"></a>6.8 基数排序（Radix Sort）</h3><ul>
<li>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配)至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</li>
<li>基数排序是一种典型的以空间交换时间的算法实现。</li>
<li>基数排序一般不对包含负数的数组进行排序，如果需要对负数排序，必须再改进算法。</li>
</ul>
<p>图解：</p>
<p><img src= "/img/loading.gif" data-lazy-src="http://img.reainyday.top/jishu1.jpg"></p>
<p><img src= "/img/loading.gif" data-lazy-src="http://img.reainyday.top/jishu2.jpg" alt="jishu2"></p>
<p><img src= "/img/loading.gif" data-lazy-src="http://img.reainyday.top/jishu3.jpg" alt="jishu3"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSortTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int[] arr = &#123;1, 3, 5, 7, 6, 2&#125;;</span></span><br><span class="line"><span class="comment">//        int[] arr = &#123;1, 3, 5,5,7, 6, 2,2&#125;;</span></span><br><span class="line"><span class="comment">//        int[] arr = &#123;-9,78,0,23,-567,70, -1,900, 4561&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">53</span>, <span class="number">3</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">14</span>, <span class="number">214</span>,<span class="number">1000</span>&#125;;</span><br><span class="line">        radixSort(arr);</span><br><span class="line">       </span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意，基数排序是不需要递归的</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][array.length];<span class="comment">//使用最坏情况，arr.length防止溢出</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];<span class="comment">//记录每个桶中元素数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到最大值</span></span><br><span class="line">        <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">                max = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历出最大值的位数</span></span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">            max/=<span class="number">10</span>;</span><br><span class="line">            max_len++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = <span class="number">1</span>; i &lt; max_len; i++, n *= <span class="number">10</span>) &#123;<span class="comment">//通过位数确定排序次数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j++) &#123;<span class="comment">//将每个数放入对应的桶</span></span><br><span class="line">                <span class="keyword">int</span> temp = array[j] / n % (<span class="number">10</span>);</span><br><span class="line">                bucket[temp][count[temp]++] = array[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将每次排序好的按桶顺序放回数组</span></span><br><span class="line">            <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; <span class="number">10</span>; i1++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count[i1]; j++) &#123;</span><br><span class="line">                    array[index++] = bucket[i1][j];</span><br><span class="line">                &#125;</span><br><span class="line">                count[i1] = <span class="number">0</span>;<span class="comment">//把count数组清零</span></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7、查找"><a href="#7、查找" class="headerlink" title="7、查找"></a>7、查找</h2><ul>
<li>分类：<ol>
<li>顺序（线性）查找</li>
<li>二分查找/折半查找</li>
<li>插值查找</li>
<li>斐波那契查找</li>
</ol>
</li>
</ul>
<h3 id="7-1-线性查找"><a href="#7-1-线性查找" class="headerlink" title="7.1 线性查找"></a>7.1 线性查找</h3><ul>
<li>线性查找的数组可以是无序的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线性查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceSearchTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> value=<span class="number">6</span>;</span><br><span class="line">        <span class="keyword">int</span> key=sequenceSearch(array,value);</span><br><span class="line">        <span class="keyword">if</span>(key!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(value+<span class="string">&quot;位于数组的第&quot;</span>+(key+<span class="number">1</span>)+<span class="string">&quot;位置&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未找到该元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sequenceSearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]==value)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-二分查找"><a href="#7-2-二分查找" class="headerlink" title="7.2 二分查找"></a>7.2 二分查找</h3><ul>
<li>二分查找必须确保数组本身是顺序的。</li>
</ul>
<p><strong>递归实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">int</span> key = binarySearch(array, <span class="number">0</span>, array.length - <span class="number">1</span>, value);</span><br><span class="line">        <span class="keyword">if</span> (key != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(value + <span class="string">&quot;位于数组的第&quot;</span> + (key + <span class="number">1</span>) + <span class="string">&quot;位置&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未找到该元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (value &gt; array[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(array, mid + <span class="number">1</span>, right, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; array[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(array, left, mid - <span class="number">1</span>, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="7-3-插值查找"><a href="#7-3-插值查找" class="headerlink" title="7.3 插值查找"></a>7.3 插值查找</h3><ul>
<li>插值查找相比二分查找可以说是更人性化，就好比你直接通过翻字典查单词，当你查abandon时，你用二分就是每次都在字典中间找，但显然，我们知道a开头的单词在字典很前面的部分，插值查找就是利用这种特性，所以插值查找就更像一个真人去查单词；</li>
<li>对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快；</li>
<li>关键字分布不均匀的情况下，该方法不一定比折半查找要好。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插值查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterpolationSearchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> key = interpolationSearch(array, <span class="number">0</span>, array.length - <span class="number">1</span>, value);</span><br><span class="line">        <span class="keyword">if</span>(key!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(value+<span class="string">&quot;位于数组的第&quot;</span>+(key+<span class="number">1</span>)+<span class="string">&quot;位置&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未找到该元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">interpolationSearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查找中...&quot;</span>);</span><br><span class="line">        <span class="comment">//这儿的判断是不可省的，否则可能会数组越界，因为 (value - array[left]) / (array[right] - array[left])不能大于或小于零</span></span><br><span class="line">        <span class="keyword">if</span> (value &lt; array[<span class="number">0</span>] || value &gt; array[array.length - <span class="number">1</span>] || left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) * (value - array[left]) / (array[right] - array[left]);</span><br><span class="line">        <span class="keyword">if</span> (value &gt; array[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> interpolationSearch(array, mid + <span class="number">1</span>, right, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; array[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> interpolationSearch(array, left, mid - <span class="number">1</span>, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-斐波那契查找"><a href="#7-4-斐波那契查找" class="headerlink" title="7.4 斐波那契查找"></a>7.4 斐波那契查找</h3><p>（也称黄金分割法）</p>
<ul>
<li>斐波那契搜索就是在二分查找的基础上根据斐波那契数列进行分割的。在斐波那契数列找一个等于略大于查找表中元素个数的数F[n]，将原查找表扩展为长度为F[n] (如果要补充元素，则补充重复最后一个元素，直到满足F[n]个元素)，完成后进行斐波那契分割，即F[n]个元素分割为前半部分F[n-1]个元素，后半部分F[n-2]个元素，找出要查找的元素在那一部分并递归，直到找到。</li>
<li>在最坏情况下，斐波那契查找的时间复杂度还是O(log2n)，且其期望复杂度也为O(log2n)，但是与折半查找相比，斐波那契查找的优点是它只涉及加法和减法运算，而不用除法，而除法比加减法要占用更多的时间，因此，斐波那契查找的运行时间理论上比折半查找小，但是还是得视具体情况而定。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> maxSize = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;index=&quot;</span> + fibSearch(arr, <span class="number">1</span>));<span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为后面我们mid=low+F(k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列</span></span><br><span class="line">    <span class="comment">//非递归方法得到一个斐波那契数列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fib() &#123;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写斐波那契查找算法</span></span><br><span class="line">    <span class="comment">//使用非递归的方式编写算法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a   数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 我们需要查找的关键码(值)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回对应的下标，如果没有-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibSearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = a.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">//表示斐波那契分割数值的下标</span></span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>; <span class="comment">//存放mid 值</span></span><br><span class="line">        <span class="keyword">int</span> f[] = fib(); <span class="comment">//获取到斐波那契数列</span></span><br><span class="line">        <span class="comment">//获取到斐波那契分割数值的下标</span></span><br><span class="line">        <span class="keyword">while</span> (high &gt; f[k] - <span class="number">1</span>) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为f[k] 值可能大于a 的长度，因此我们需要使用Arrays 类，构造一个新的数组，并指向temp[]</span></span><br><span class="line">        <span class="comment">//不足的部分会使用0 填充</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = Arrays.copyOf(a, f[k]);</span><br><span class="line">        <span class="comment">//实际上需求使用a 数组最后的数填充temp</span></span><br><span class="line">        <span class="comment">//举例:</span></span><br><span class="line">        <span class="comment">//temp = &#123;1,8, 10, 89, 1000, 1234, 0, 0&#125; =&gt; &#123;1,8, 10, 89, 1000, 1234, 1234, 1234,&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = high + <span class="number">1</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            temp[i] = a[high];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用while 来循环处理，找到我们的数key</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123; <span class="comment">// 只要这个条件满足，就可以找</span></span><br><span class="line">            mid = low + f[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; temp[mid]) &#123; <span class="comment">//我们应该继续向数组的前面查找(左边)</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//为甚是k--</span></span><br><span class="line">                <span class="comment">//说明</span></span><br><span class="line">                <span class="comment">//1. 全部元素= 前面的元素+ 后边元素</span></span><br><span class="line">                <span class="comment">//2. f[k] = f[k-1] + f[k-2]</span></span><br><span class="line">                <span class="comment">//因为前面有f[k-1]个元素,所以可以继续拆分f[k-1] = f[k-2] + f[k-3]</span></span><br><span class="line">                <span class="comment">//即在f[k-1] 的前面继续查找k--</span></span><br><span class="line">                <span class="comment">//即下次循环mid = f[k-1-1]-1</span></span><br><span class="line">                k--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; temp[mid]) &#123; <span class="comment">// 我们应该继续向数组的后面查找(右边)</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//为什么是k -=2</span></span><br><span class="line">                <span class="comment">//说明</span></span><br><span class="line">                <span class="comment">//1. 全部元素= 前面的元素+ 后边元素</span></span><br><span class="line">                <span class="comment">//2. f[k] = f[k-1] + f[k-2]</span></span><br><span class="line">                <span class="comment">//3. 因为后面我们有f[k-2] 所以可以继续拆分f[k-1] = f[k-3] + f[k-4]</span></span><br><span class="line">                <span class="comment">//4. 即在f[k-2] 的前面进行查找k -=2</span></span><br><span class="line">                <span class="comment">//5. 即下次循环mid = f[k - 1 - 2] - 1</span></span><br><span class="line">                k -= <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//找到</span></span><br><span class="line">                <span class="comment">//需要确定，返回的是哪个下标</span></span><br><span class="line">                <span class="keyword">if</span> (mid &lt;= high) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> high;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8、哈希表（散列）"><a href="#8、哈希表（散列）" class="headerlink" title="8、哈希表（散列）"></a>8、哈希表（散列）</h2><ul>
<li><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
</li>
<li><p>例题：</p>
<p>有一个公司,当有新的员工来报道时，要求将该员工的信息加入(id,性别,年龄,住址..)，当输入该员工的id 时,要求查找到该员工的所有信息。<br>要求: </p>
<ol>
<li>不使用数据库,,速度越快越好=&gt;哈希表(散列)；</li>
<li>添加时，保证按照id 从低到高插入；</li>
<li>使用链表来实现哈希表, 该链表不带表头[即: 链表的第一个结点就存放雇员信息]。</li>
</ol>
</li>
<li><p>图解：</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="http://img.reainyday.top/hashtable0.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哈希表测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashTable hashTable = <span class="keyword">new</span> HashTable(<span class="number">3</span>);</span><br><span class="line">        hashTable.add(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        hashTable.add(<span class="number">5</span>, <span class="string">&quot;电七&quot;</span>);</span><br><span class="line">        hashTable.add(<span class="number">2</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        hashTable.add(<span class="number">6</span>, <span class="string">&quot;钱八&quot;</span>);</span><br><span class="line">        hashTable.add(<span class="number">9</span>, <span class="string">&quot;孙十&quot;</span>);</span><br><span class="line">        hashTable.add(<span class="number">3</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        hashTable.add(<span class="number">4</span>, <span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">        hashTable.show();</span><br><span class="line">        hashTable.findById(<span class="number">6</span>);</span><br><span class="line">        hashTable.deleteById(<span class="number">3</span>);</span><br><span class="line">        hashTable.deleteById(<span class="number">6</span>);</span><br><span class="line">        hashTable.deleteById(<span class="number">9</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后：&quot;</span>);</span><br><span class="line">        hashTable.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> EmployLinkList[] employLinkListArray;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTable</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        employLinkListArray = <span class="keyword">new</span> EmployLinkList[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            employLinkListArray[i] = <span class="keyword">new</span> EmployLinkList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        Employ employ = <span class="keyword">new</span> Employ(id, name);</span><br><span class="line">        <span class="keyword">int</span> index = hashFun(id);</span><br><span class="line">        employLinkListArray[index].add(employ);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;条链表：&quot;</span>);</span><br><span class="line">            employLinkListArray[i].show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employ <span class="title">findById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = hashFun(id);</span><br><span class="line">        Employ temp = employLinkListArray[index].findById(id);</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;查找结果为空&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;查找结果：&quot;</span> + temp.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = hashFun(id);</span><br><span class="line">        employLinkListArray[index].deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//散列函数——简单取模法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashFun</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id % size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//员工链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployLinkList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Employ head = <span class="keyword">null</span>;<span class="comment">//不使用单独的表头结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加员工结点（按顺序插入）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Employ employ)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = employ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Employ temp = head;</span><br><span class="line">            <span class="comment">//如果插入结点id小于头结点id,将插入结点指向原本头节点，并让插入节点成为新的头结点</span></span><br><span class="line">            <span class="keyword">if</span> (temp.id &gt; employ.id) &#123;</span><br><span class="line">                employ.next = temp;</span><br><span class="line">                head = employ;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//遍历，如果遍历至末尾结点仍id仍小于插入结点，则插入到末尾</span></span><br><span class="line">                <span class="comment">//否则，插入到链表中间</span></span><br><span class="line">                <span class="keyword">while</span> (temp.next != <span class="keyword">null</span> &amp;&amp; temp.next.id &lt; employ.id) &#123;</span><br><span class="line">                    temp = temp.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    temp.next = employ;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    employ.next = temp.next;</span><br><span class="line">                    temp.next = employ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Employ temp = head;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;=&gt; 链表为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;=&gt; &quot;</span> + temp.toString());</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employ <span class="title">findById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        Employ temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.id == id) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        Employ temp = head;</span><br><span class="line">        <span class="keyword">if</span>(head.id==id)&#123;</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (temp.next!=<span class="keyword">null</span>&amp;&amp;temp.next.id!=id)&#123;</span><br><span class="line">                temp=temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;该结点不存在，无法删除&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp.next=temp.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//员工结点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employ</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    String adress;</span><br><span class="line">    Employ next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employ</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Employ&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="9、树"><a href="#9、树" class="headerlink" title="9、树"></a>9、树</h2><h3 id="9-1-二叉树"><a href="#9-1-二叉树" class="headerlink" title="9.1 二叉树"></a>9.1 二叉树</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉树</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Node node1 = <span class="keyword">new</span> Node(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        Node node2 = <span class="keyword">new</span> Node(<span class="number">2</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">        Node node3 = <span class="keyword">new</span> Node(<span class="number">3</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        Node node4 = <span class="keyword">new</span> Node(<span class="number">4</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line">        Node node5 = <span class="keyword">new</span> Node(<span class="number">5</span>, <span class="string">&quot;E&quot;</span>);</span><br><span class="line">        Node node6 = <span class="keyword">new</span> Node(<span class="number">6</span>, <span class="string">&quot;F&quot;</span>);</span><br><span class="line">        Node node7 = <span class="keyword">new</span> Node(<span class="number">7</span>, <span class="string">&quot;G&quot;</span>);</span><br><span class="line"></span><br><span class="line">        node1.setLeft(node2);</span><br><span class="line">        node1.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line">        node3.setRight(node7);</span><br><span class="line"></span><br><span class="line">        BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree(node1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历：&quot;</span>);</span><br><span class="line">        binaryTree.preTraverse();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n中序遍历：&quot;</span>);</span><br><span class="line">        binaryTree.midTraverse();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n后序遍历：&quot;</span>);</span><br><span class="line">        binaryTree.lastTraverse();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历查找：&quot;</span>);</span><br><span class="line">        binaryTree.preTraverseSearch(<span class="number">9</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历查找：&quot;</span>);</span><br><span class="line">        binaryTree.preTraverseSearch(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历查找：&quot;</span>);</span><br><span class="line">        binaryTree.lastTraverseSearch(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;删除节点后：&quot;</span>);</span><br><span class="line">        binaryTree.deleteById(<span class="number">3</span>);</span><br><span class="line">        binaryTree.preTraverse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTree</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preTraverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;根节点为空，无法查找&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root.preTraverse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midTraverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;根节点为空，无法查找&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root.midTraverse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lastTraverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;根节点为空，无法查找&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root.lastTraverse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">preTraverseSearch</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        Node temp = root.preTraverseSearch(id);</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未查找到该值&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;节点&quot;</span> + id + <span class="string">&quot;的值为&quot;</span> + temp.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">midTraverseSearch</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        Node temp = root.midTraverseSearch(id);</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未查找到该值&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;节点&quot;</span> + id + <span class="string">&quot;的值为&quot;</span> + temp.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">lastTraverseSearch</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        Node temp = root.lastTraverseSearch(id);</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未查找到该值&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;节点&quot;</span> + id + <span class="string">&quot;的值为&quot;</span> + temp.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;根节点为空，无法删除&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.getId() == id) &#123;</span><br><span class="line">            root = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.deleteById(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="keyword">private</span> Node left;</span><br><span class="line">    <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> id, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="comment">//如果是叶子节点，则删除该节点</span></span><br><span class="line">    <span class="comment">//如果是非叶子节点，则删除该子树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.id == id) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.id == id) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.deleteById(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.deleteById(id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">preTraverseSearch</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.id == id) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = <span class="keyword">this</span>.left.preTraverseSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = <span class="keyword">this</span>.right.preTraverseSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">midTraverseSearch</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        Node temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = <span class="keyword">this</span>.left.midTraverseSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.id == id) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = <span class="keyword">this</span>.right.midTraverseSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后续遍历查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">lastTraverseSearch</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        Node temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = <span class="keyword">this</span>.left.lastTraverseSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = <span class="keyword">this</span>.right.lastTraverseSearch(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.id == id) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preTraverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(value);</span></span><br><span class="line">        System.out.print(id + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            left.preTraverse();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            right.preTraverse();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midTraverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            left.midTraverse();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(value);</span></span><br><span class="line">        System.out.print(id + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            right.midTraverse();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lastTraverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            left.lastTraverse();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            right.lastTraverse();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(value);</span></span><br><span class="line">        System.out.print(id + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(Node left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(Node right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-2-顺序存储二叉树"><a href="#9-2-顺序存储二叉树" class="headerlink" title="9.2 顺序存储二叉树"></a>9.2 顺序存储二叉树</h3><ul>
<li>二叉树顺序存储是二叉树的一种存储方式。</li>
<li>将二叉树存储在一个数组中，通过存储元素的下标反映元素之间的父子关系。</li>
<li>树的编号：从树根起，自上层至下层，每层自左至右地给所有结点编号</li>
<li>特点：<ol>
<li>顺序二叉树通常只考虑完全二叉树</li>
<li>第n 个元素的左子节点为2 * n + 1</li>
<li>第n 个元素的右子节点为2 * n + 2</li>
<li>第n 个元素的父节点为(n-1) / 2</li>
<li>n : 表示二叉树中的第几个元素和数组下标(按0 开始编号如图所示)</li>
</ol>
</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顺序存储二叉树</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceTreeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        SequenceTree sequenceTree=<span class="keyword">new</span> SequenceTree(arr);</span><br><span class="line">        sequenceTree.preOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SequenceTree</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SequenceTree</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span>||array==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;无法遍历&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;array.length)&#123;</span><br><span class="line">            System.out.println(array[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">2</span>*index+<span class="number">1</span>)&lt;array.length)&#123;</span><br><span class="line">            preOrder(<span class="number">2</span>*index+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">2</span>*index+<span class="number">2</span>)&lt;array.length)&#123;</span><br><span class="line">            preOrder(<span class="number">2</span>*index+<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-线索化二叉树"><a href="#9-3-线索化二叉树" class="headerlink" title="9.3 线索化二叉树"></a>9.3 线索化二叉树</h3><ul>
<li>n 个结点的二叉链表中含有n+1 【公式2n-(n-1)=n+1】个空指针域。利用二叉链表中的空指针域，存放指向<br>该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”）。</li>
<li>这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种。</li>
<li>一个结点的前一个结点，称为前驱结点，<br> 一个结点的后一个结点，称为后继结点。</li>
<li>注意：<ul>
<li>当线索化二叉树后，Node 节点的属性left 和right ，有如下情况:<ol>
<li>left 指向的是左子树，也可能是指向的前驱节点；</li>
<li>right  指向的是右子树，也可能是指向后继节点。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>思路(中序遍历为例）:</p>
<ol>
<li>首先，我们需要通过中序遍历遍历每个节点，即先写出二叉树的中序遍历；</li>
<li>我们需要一个pre值记录当前节点的前一个节点，以方便设置当前节点的前驱结点。</li>
<li>是否有前驱节点判断：当前节点左子树为空，pre节点不为空。</li>
<li>是否有后继节点判断：当前节点右子树为空，pre节点不为空。</li>
<li>前驱节点：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">node.setLeft(pre);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>后继结点：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pre.setRight(node);<span class="comment">//注意，后继结点是对pre进行操作，当前节点是无法知道自己的后继结点的，因为后继节点不一定就是node的右子节点。</span></span><br></pre></td></tr></table></figure>

<p>注意：在继续向右递归前记得将当前节点赋值给pre。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTreeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TNode node1 = <span class="keyword">new</span> TNode(<span class="number">1</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        TNode node2 = <span class="keyword">new</span> TNode(<span class="number">2</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">        TNode node3 = <span class="keyword">new</span> TNode(<span class="number">3</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        TNode node4 = <span class="keyword">new</span> TNode(<span class="number">4</span>, <span class="string">&quot;D&quot;</span>);</span><br><span class="line">        TNode node5 = <span class="keyword">new</span> TNode(<span class="number">5</span>, <span class="string">&quot;E&quot;</span>);</span><br><span class="line">        TNode node6 = <span class="keyword">new</span> TNode(<span class="number">6</span>, <span class="string">&quot;F&quot;</span>);</span><br><span class="line">        TNode node7 = <span class="keyword">new</span> TNode(<span class="number">7</span>, <span class="string">&quot;G&quot;</span>);</span><br><span class="line"></span><br><span class="line">        node1.setLeft(node2);</span><br><span class="line">        node1.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line">        node3.setRight(node7);</span><br><span class="line"></span><br><span class="line">        ThreadedBinaryTree threadedBinaryTree = <span class="keyword">new</span> ThreadedBinaryTree(node1);</span><br><span class="line">        threadedBinaryTree.midTraverseThreaded(node1);</span><br><span class="line"></span><br><span class="line">        System.out.println(node4);</span><br><span class="line">        System.out.println(node6.getLeft().getId());</span><br><span class="line">        System.out.println(node6.getRight().getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TNode root;</span><br><span class="line">    <span class="keyword">private</span> TNode pre;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadedBinaryTree</span><span class="params">(TNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以中序遍历来线索化二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midTraverseThreaded</span><span class="params">(TNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        midTraverseThreaded(node.getLeft());</span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.getRight() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            pre.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = node;</span><br><span class="line">        midTraverseThreaded(node.getRight());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="keyword">private</span> TNode left;</span><br><span class="line">    <span class="keyword">private</span> TNode right;</span><br><span class="line">    <span class="comment">//leftType为0时表示指向的是左子树，为1时表示指向的是遍历的前驱结点；</span></span><br><span class="line">    <span class="comment">//rightType同理。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> leftType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rightType;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TNode</span><span class="params">(<span class="keyword">int</span> id, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRightType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(TNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(TNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftType</span><span class="params">(<span class="keyword">int</span> leftType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightType</span><span class="params">(<span class="keyword">int</span> rightType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;TNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, value=&#x27;&quot;</span> + value + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线索遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midTraverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;二叉树为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    TNode node=root;</span><br><span class="line">    <span class="keyword">while</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(node.getLeftType()==<span class="number">0</span>)&#123;<span class="comment">//注意此处不能使用node.getLeft()!=null为条件，否则整体会进入死循环</span></span><br><span class="line">            node=node.getLeft();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node);</span><br><span class="line">        <span class="keyword">while</span>(node.getRightType()==<span class="number">1</span>)&#123;</span><br><span class="line">            node=node.getRight();</span><br><span class="line">            System.out.println(node);</span><br><span class="line">        &#125;</span><br><span class="line">        node=node.getRight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-4-堆排序"><a href="#9-4-堆排序" class="headerlink" title="9.4 堆排序"></a>9.4 堆排序</h3><ul>
<li><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复<br>杂度均为O(nlogn)，它也是不稳定排序。</p>
</li>
<li><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意: 没有要求结点的左孩子的值和右孩子的值的大小关系。</p>
</li>
<li><p>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p>
</li>
<li><p>一般升序采用大顶堆，降序采用小顶堆。</p>
</li>
<li><p>基本思想：</p>
<ol>
<li>先将数组构造成一个大顶堆：从第二个节点开始遍历，如果该节点大于父节点的值，则交换两点的值，并继续向上遍历，直至节点值小于父节点，对下一个节点进行判断。</li>
<li>将头节点与末尾节点的值交换，对前size-1个元素操作：判断此时头节点是否大于该节点的两个子节点中的最大值，不大于则交换位置，并对交换后的位置继续判断，直至该节点为叶子节点或者两个子节点都小于该节点。</li>
</ol>
</li>
<li><p>参考：<a href="https://blog.csdn.net/u010452388/article/details/81283998">https://blog.csdn.net/u010452388/article/details/81283998</a></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSortTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">58</span>,<span class="number">12</span>,<span class="number">24</span>&#125;;<span class="comment">//待排序数组即顺序存储二叉树</span></span><br><span class="line">        <span class="keyword">int</span> size = array.length;<span class="comment">//构建堆长度</span></span><br><span class="line">        heapSort(array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            System.out.print(array[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//堆排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造大顶堆</span></span><br><span class="line">        heapInsert(arr);</span><br><span class="line">        <span class="keyword">int</span> size = arr.length;</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//固定最大值</span></span><br><span class="line">            swap(arr, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">            size--;</span><br><span class="line">            <span class="comment">//构造大顶堆</span></span><br><span class="line">            heapify(arr, <span class="number">0</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造大顶堆</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lagestNum;</span><br><span class="line">        <span class="keyword">int</span> index;<span class="comment">//当前索引</span></span><br><span class="line">        <span class="keyword">int</span> parentIndex;<span class="comment">//父节点索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">            parentIndex = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> (array[index] &gt; array[parentIndex]) &#123;</span><br><span class="line">                swap(array, index, parentIndex);</span><br><span class="line">                index = parentIndex;</span><br><span class="line">                parentIndex = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将剩余元素转换为大根堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">            <span class="keyword">int</span> largestIndex;</span><br><span class="line">            <span class="comment">//判断孩子中较大的值的索引（要确保右孩子在size范围之内）</span></span><br><span class="line">            <span class="keyword">if</span> (arr[left] &lt; arr[right] &amp;&amp; right &lt; size) &#123;</span><br><span class="line">                largestIndex = right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                largestIndex = left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较父结点的值与孩子中较大的值，并确定最大值的索引</span></span><br><span class="line">            <span class="keyword">if</span> (arr[index] &gt; arr[largestIndex]) &#123;</span><br><span class="line">                largestIndex = index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果父结点索引是最大值的索引，那已经是大根堆了，则退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (index == largestIndex) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//父结点不是最大值，与孩子中较大的值交换</span></span><br><span class="line">            swap(arr, largestIndex, index);</span><br><span class="line">            <span class="comment">//将索引指向孩子中较大的值的索引</span></span><br><span class="line">            index = largestIndex;</span><br><span class="line">            <span class="comment">//重新计算交换之后的孩子的索引</span></span><br><span class="line">            left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">            right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> index, <span class="keyword">int</span> parentIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        temp = array[index];</span><br><span class="line">        array[index] = array[parentIndex];</span><br><span class="line">        array[parentIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-5-哈夫曼树"><a href="#9-5-哈夫曼树" class="headerlink" title="9.5 哈夫曼树"></a>9.5 哈夫曼树</h3><ul>
<li><p>给定n个权值作为n个<strong>叶子结点</strong>，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为<br>最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。</p>
</li>
<li><p>赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>
</li>
<li><p>路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L 层结点的路径长度为L-1。</p>
</li>
<li><p>结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结<br>点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。</p>
</li>
<li><p>树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weighted path<br>length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。</p>
</li>
<li><p>基本思想：</p>
<ol>
<li>从小到大进行排序, 将每一个数据，每个数据都是一个节点， 每个节点可以看成是一颗最简单的二叉树。</li>
<li>取出根节点权值最小的两颗二叉树。</li>
<li>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和。</li>
<li>再将这颗新的二叉树，以根节点的权值大小再次排序， 不断重复1-2-3-4 的步骤，直到数列中，所有的数<br>据都被处理，就得到一颗赫夫曼树。</li>
</ol>
</li>
<li><p>图解：</p>
<p>​        {13, 7, 8, 3, 29, 6, 1}</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="http://img.reainyday.top/huffmantree1.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈夫曼树实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTreeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">13</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">29</span>, <span class="number">6</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        ArrayList&lt;HNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> HNode(array[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        HNode tree = huffmanTree(list);</span><br><span class="line">        tree.preOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HNode <span class="title">huffmanTree</span><span class="params">(ArrayList&lt;HNode&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Collections.sort(list);</span><br><span class="line">            HNode left = list.get(<span class="number">0</span>);</span><br><span class="line">            HNode right = list.get(<span class="number">1</span>);</span><br><span class="line">            HNode parentNode = <span class="keyword">new</span> HNode(left.getValue() + right.getValue());</span><br><span class="line">            parentNode.setLeft(left);</span><br><span class="line">            parentNode.setRight(right);</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">            list.add(parentNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HNode</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">HNode</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> HNode left;</span><br><span class="line">    <span class="keyword">private</span> HNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="keyword">this</span>.value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(HNode o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value - o.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&quot;, left=&quot;</span> + left +</span><br><span class="line">                <span class="string">&quot;, right=&quot;</span> + right +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-6-哈夫曼编码"><a href="#9-6-哈夫曼编码" class="headerlink" title="9.6 哈夫曼编码"></a>9.6 哈夫曼编码</h3><ul>
<li><p>哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式，哈夫曼编码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，该方法完全依据字符出现概率来构造异字头的平均长度最短的码字，有时称之为最佳编码，一般就叫做Huffman编码（有时也称为霍夫曼编码）。</p>
</li>
<li><p>前缀编码 是指对字符集进行编码时，要求字符集中任一字符的编码都不是其它字符的编码的前缀。哈夫曼编码满足前缀编码的条件，因为根节点到每个叶子节点的路径都不可能经过其他叶子节点。</p>
</li>
<li><p>传输字符串： i like like like java do you like a java</p>
<ul>
<li>d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 :9 // 各个字符对应的个数</li>
<li>按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值</li>
</ul>
</li>
<li><p>构成哈夫曼树步骤：</p>
<ol>
<li>从小到大进行排序, 将每一个数据，每个数据都是一个节点， 每个节点可以看成是一颗最简单的二叉树；</li>
<li>取出根节点权值最小的两颗二叉树；</li>
<li>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和；</li>
<li>再将这颗新的二叉树，以根节点的权值大小再次排序， 不断重复1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树。</li>
</ol>
</li>
<li><p>根据赫夫曼树，给各个字符,规定编码(前缀编码)， 向左的路径为0 向右的路径为1。</p>
<p>o: 1000 u: 10010 d: 100110 y: 100111 i: 101 a : 110 k: 1110 e: 1111 j: 0000 v: 0001 l: 001 : 01</p>
</li>
<li><p>按照上面的赫夫曼编码，我们的”i like like like java do you like a java” 字符串对应的编码为(注意这里我们使用的无损压缩)。<br>1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110 通过赫夫曼编码处理长度为133。</p>
</li>
<li><p>注意, 这个赫夫曼树根据排序方法不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，但是wpl 是一样的，都是最小的, 最后生成的赫夫曼编码的长度是一样。</p>
</li>
<li><p>压缩流程：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;i like like like java do you like a java&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = content.getBytes();<span class="comment">//注意，Byte为java.lang包中的一个封装类，而byte是java的基本数据类型</span></span><br><span class="line">        bytes=huffmanZip(bytes);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">            System.out.println(bytes[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装压缩的所有方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] huffmanZip(<span class="keyword">byte</span>[] bytes)&#123;</span><br><span class="line">        ArrayList&lt;CNode&gt; list = getNodes(bytes);</span><br><span class="line">        CNode node = createHaffmanTree(list);</span><br><span class="line">        node.preOrder();</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        getCode(node, builder, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        bytes = zip(bytes);</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将byte数组元素转化为节点list</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;CNode&gt; <span class="title">getNodes</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;CNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        HashMap&lt;Byte, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">            Integer count = map.get(b);</span><br><span class="line">            map.put(b, count == <span class="keyword">null</span> ? <span class="number">1</span> : count + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> CNode(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过节点list创建哈夫曼树</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> CNode <span class="title">createHaffmanTree</span><span class="params">(ArrayList&lt;CNode&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Collections.sort(list);</span><br><span class="line">            CNode left = list.get(<span class="number">0</span>);</span><br><span class="line">            CNode right = list.get(<span class="number">1</span>);</span><br><span class="line">            CNode parent = <span class="keyword">new</span> CNode(left.weight + right.weight);</span><br><span class="line">            parent.left = left;</span><br><span class="line">            parent.right = right;</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">            list.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取每个叶子节点的哈夫曼编码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getCode</span><span class="params">(CNode node, StringBuilder builder, String code)</span> </span>&#123;</span><br><span class="line">        StringBuilder builder2 = <span class="keyword">new</span> StringBuilder(builder);<span class="comment">//必须创建builder2，直接是用builder是错误的</span></span><br><span class="line">        builder2.append(code);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.data == <span class="keyword">null</span>) &#123;<span class="comment">//叶子节点</span></span><br><span class="line">                getCode(node.left, builder2, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">                getCode(node.right, builder2, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(node.data, builder2.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将哈夫曼编码压缩为byte数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] zip(<span class="keyword">byte</span>[] bytes) &#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (Byte b : bytes) &#123;</span><br><span class="line">            stringBuilder.append(map.get(b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = (stringBuilder.length() + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes1=<span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuilder.length(); i+=<span class="number">8</span>) &#123;</span><br><span class="line">            String str;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">8</span>&lt;stringBuilder.length())&#123;</span><br><span class="line">                str=stringBuilder.substring(i,i+<span class="number">8</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                str=stringBuilder.substring(i);</span><br><span class="line">            &#125;</span><br><span class="line">            bytes1[index++]= (<span class="keyword">byte</span>) Integer.parseInt(str,<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNode</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">CNode</span>&gt; </span>&#123;</span><br><span class="line">    Byte data;<span class="comment">//存放数据。如：&#x27;a&#x27;=》97</span></span><br><span class="line">    <span class="keyword">int</span> weight;<span class="comment">//权重，即字符出现次数</span></span><br><span class="line">    CNode left;</span><br><span class="line">    CNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CNode</span><span class="params">(Byte data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CNode</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CNode</span><span class="params">(Byte data, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.toString());</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(CNode o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-7-二叉排序树（BST"><a href="#9-7-二叉排序树（BST" class="headerlink" title="9.7 二叉排序树（BST)"></a>9.7 二叉排序树（BST)</h3><ul>
<li>二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。</li>
<li>二叉排序树可能是一棵空树；也可能是具有下列性质的二叉树：<ol>
<li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>左、右子树也分别为二叉排序树；</li>
</ol>
</li>
<li>二叉排序树通过中序遍历得到的序列是一个升序序列。</li>
</ul>
<p>创建和遍历二叉排序树：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉排序树</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTreeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        BinarySortTree binarySortTree = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            BNode bNode = <span class="keyword">new</span> BNode(arr[i]);</span><br><span class="line">            binarySortTree.add(bNode);</span><br><span class="line">        &#125;</span><br><span class="line">        binarySortTree.midOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span> </span>&#123;</span><br><span class="line">    BNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySortTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySortTree</span><span class="params">(BNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(BNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = node;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root.add(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;树为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root.midOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    BNode left;</span><br><span class="line">    BNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(BNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                right = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            left.midOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            right.midOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>二叉排序树结点的删除：<ol>
<li>当待删除结点为叶子结点时，删除后不影响整棵树的结构，所以可以直接删除；</li>
<li>当待删除结点只有一个子结树时，用子结点替代该结点即可；</li>
<li>当待删除结点左右子树都不为空时，找到需要删除的结点p的直接前驱或直接后继（中序遍历）s，用s来替换结点p，然后再删除此结点s。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dreamin.tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉排序树</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTreeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        BinarySortTree binarySortTree = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            BNode bNode = <span class="keyword">new</span> BNode(arr[i]);</span><br><span class="line">            binarySortTree.add(bNode);</span><br><span class="line">        &#125;</span><br><span class="line">        binarySortTree.midOrder();</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后：&quot;</span>);</span><br><span class="line">        binarySortTree.deleteByValue(<span class="number">3</span>);</span><br><span class="line">        binarySortTree.midOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span> </span>&#123;</span><br><span class="line">    BNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySortTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySortTree</span><span class="params">(BNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BNode <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.search(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找父节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BNode <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找后继结点值（即当前节点的右子树所有结点的最小值）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextNode</span><span class="params">(BNode node)</span> </span>&#123;</span><br><span class="line">        BNode temp = node.right;</span><br><span class="line">        <span class="keyword">while</span> (temp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = temp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        deleteByValue(temp.value);<span class="comment">//此时temp只有可能是叶子节点或只有一颗子树的结点，所以可以删除</span></span><br><span class="line">        <span class="keyword">return</span> temp.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteByValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BNode currentNode = search(value);<span class="comment">//当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BNode pre = searchParent(value);</span><br><span class="line">        <span class="comment">//如果是叶子结点，父节点的指向置为空</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode.left == <span class="keyword">null</span> &amp;&amp; currentNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root == currentNode) &#123;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pre.left != <span class="keyword">null</span> &amp;&amp; pre.left == currentNode) &#123;</span><br><span class="line">                pre.left = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre.right != <span class="keyword">null</span> &amp;&amp; pre.right == currentNode) &#123;</span><br><span class="line">                pre.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果节点有两颗子树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (currentNode.left != <span class="keyword">null</span> &amp;&amp; currentNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> next_value = nextNode(currentNode);</span><br><span class="line">            currentNode.value = next_value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果节点只有一颗子树</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pre.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    root = pre.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    root = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pre.left == currentNode &amp;&amp; currentNode.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pre.left = currentNode.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre.left == currentNode &amp;&amp; currentNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pre.left = currentNode.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre.right == currentNode &amp;&amp; currentNode.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pre.right = currentNode.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.right = currentNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(BNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = node;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root.add(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;树为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root.midOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    BNode left;</span><br><span class="line">    BNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找后继结点(即结点右子树中的最小值）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextNode</span><span class="params">(BNode node)</span> </span>&#123;</span><br><span class="line">        node = node.right;</span><br><span class="line">        <span class="keyword">while</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        BNode parentNode = searchParent(node.value);</span><br><span class="line">        <span class="keyword">if</span> (parentNode.left == node) &#123;</span><br><span class="line">            parentNode.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parentNode.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找父节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BNode <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value == value) ||</span><br><span class="line">                (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value == value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.value &gt; value &amp;&amp; <span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> left.searchParent(value);<span class="comment">//向左查找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.value &lt; value &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right.searchParent(value);<span class="comment">//向右查找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//未找到</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BNode <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.value == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.value &gt; value) &#123;<span class="comment">//向左查找</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//未找到则返回null</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> left.search(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//向右查找</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(BNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                right = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            left.midOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            right.midOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-8-平衡二叉树（AVL树）"><a href="#9-8-平衡二叉树（AVL树）" class="headerlink" title="9.8 平衡二叉树（AVL树）"></a>9.8 平衡二叉树（AVL树）</h3><ul>
<li>平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL 树， 可以保证查询效率较高。</li>
<li>具有以下特点：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。</li>
<li>平衡因子 : 树中某结点其左子树的高度和右子树的高度之差。</li>
<li><strong>左旋示意图：</strong></li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="http://img.reainyday.top/AVL%E5%B7%A6%E6%97%8B%E8%BD%AC.png"></p>
<ul>
<li><strong>右旋转：</strong>（与左子树旋转方法相似）<ol>
<li>创建一个新的结点，值等于当前结点的值；</li>
<li>把新结点的右子树设置为当前结点的右子树；</li>
<li>把新结点的左子树设置为当前节点左子树的右子树；</li>
<li>把当前结点的值替换为左子结点的值；</li>
<li>让当前结点左子树指向左子结点的左子结点；</li>
<li>让新结点设置为当前结点的右结点。</li>
</ol>
</li>
<li><strong>条件判断：</strong><ul>
<li>当左子树高度-右子树高度 &gt; 1，满足右旋转条件:<ol>
<li>如果它的左子树的右子树高度大于它的左子树的高度，先对当前这个结点的左节点进行左旋转，在对当前结点进行右旋转的操作即可。</li>
<li>否则直接右转。</li>
</ol>
</li>
<li>当右子树高度-左子树高度 &gt; 1，满足左旋转条件:<ol>
<li>如果它的右子树的左子树高度大于它的右子树的高度，先对当前这个结点的右节点进行右旋转，在对当前结点进行左旋转的操作即可。</li>
<li>否则直接左转。</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dreamin.tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//平衡二叉排序树</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLTreeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int[] arr = &#123;4, 3, 6, 5, 7, 8&#125;;</span></span><br><span class="line"><span class="comment">//        int[] arr = &#123;10, 12, 8, 9, 7, 6&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        AVLTree avlTree = <span class="keyword">new</span> AVLTree();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            ANode node = <span class="keyword">new</span> ANode(arr[i]);</span><br><span class="line">            avlTree.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;二叉搜索树：&quot;</span>);</span><br><span class="line">        avlTree.midOrder();</span><br><span class="line">        System.out.println(<span class="string">&quot;\n根节点高度为：&quot;</span> + avlTree.root.height());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> </span>&#123;</span><br><span class="line">    ANode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AVLTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AVLTree</span><span class="params">(ANode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ANode <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.search(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找父结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ANode <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找后继结点值（即当前结点的右子树所有结点的最小值）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextNode</span><span class="params">(ANode node)</span> </span>&#123;</span><br><span class="line">        ANode temp = node.right;</span><br><span class="line">        <span class="keyword">while</span> (temp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp = temp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        deleteByValue(temp.value);<span class="comment">//此时temp只有可能是叶子结点或只有一颗子树的结点，所以可以删除</span></span><br><span class="line">        <span class="keyword">return</span> temp.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteByValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ANode currentNode = search(value);<span class="comment">//当前结点</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ANode pre = searchParent(value);</span><br><span class="line">        <span class="comment">//如果是叶子结点，父结点的指向置为空</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode.left == <span class="keyword">null</span> &amp;&amp; currentNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root == currentNode) &#123;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pre.left != <span class="keyword">null</span> &amp;&amp; pre.left == currentNode) &#123;</span><br><span class="line">                pre.left = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre.right != <span class="keyword">null</span> &amp;&amp; pre.right == currentNode) &#123;</span><br><span class="line">                pre.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果结点有两颗子树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (currentNode.left != <span class="keyword">null</span> &amp;&amp; currentNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> next_value = nextNode(currentNode);</span><br><span class="line">            currentNode.value = next_value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果结点只有一颗子树</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pre.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    root = pre.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    root = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pre.left == currentNode &amp;&amp; currentNode.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pre.left = currentNode.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre.left == currentNode &amp;&amp; currentNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pre.left = currentNode.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre.right == currentNode &amp;&amp; currentNode.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pre.right = currentNode.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.right = currentNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(ANode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = node;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root.add(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;树为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root.midOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ANode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    com.dreamin.tree.ANode left;</span><br><span class="line">    com.dreamin.tree.ANode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ANode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左旋转,主要是理清步骤</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ANode node = <span class="keyword">new</span> ANode(value);</span><br><span class="line">        node.left = left;</span><br><span class="line">        node.right = right.left;</span><br><span class="line">        value = right.value;</span><br><span class="line">        right = right.right;</span><br><span class="line">        left = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右旋转</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ANode node = <span class="keyword">new</span> ANode(value);</span><br><span class="line">        node.right = right;</span><br><span class="line">        node.left = left.right;</span><br><span class="line">        value = left.value;</span><br><span class="line">        left = left.left;</span><br><span class="line">        right = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左子树高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leftHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右子树高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rightHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前结点高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(<span class="keyword">this</span>.left == <span class="keyword">null</span> ? <span class="number">0</span> : left.height(), <span class="keyword">this</span>.right == <span class="keyword">null</span> ? <span class="number">0</span> : right.height()) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找后继结点(即结点右子树中的最小值）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextNode</span><span class="params">(com.dreamin.tree.ANode node)</span> </span>&#123;</span><br><span class="line">        node = node.right;</span><br><span class="line">        <span class="keyword">while</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        com.dreamin.tree.ANode parentNode = searchParent(node.value);</span><br><span class="line">        <span class="keyword">if</span> (parentNode.left == node) &#123;</span><br><span class="line">            parentNode.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parentNode.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找父结点</span></span><br><span class="line">    <span class="keyword">public</span> com.dreamin.tree.<span class="function">ANode <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value == value) ||</span><br><span class="line">                (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value == value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.value &gt; value &amp;&amp; <span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> left.searchParent(value);<span class="comment">//向左查找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.value &lt; value &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right.searchParent(value);<span class="comment">//向右查找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//未找到</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    <span class="keyword">public</span> com.dreamin.tree.<span class="function">ANode <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.value == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.value &gt; value) &#123;<span class="comment">//向左查找</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//未找到则返回null</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> left.search(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//向右查找</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(com.dreamin.tree.ANode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                right = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加节点时：（右子树高度-左子树高度）&gt; 1，向左旋转</span></span><br><span class="line">        <span class="keyword">if</span> (rightHeight() - leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="keyword">null</span> &amp;&amp; right.leftHeight() &gt; right.rightHeight()) &#123;</span><br><span class="line">                right.rightRotate();</span><br><span class="line">            &#125;</span><br><span class="line">            leftRotate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加节点时：（左子树高度-右子树高度）&gt; 1，向右旋转</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; left.rightHeight() &gt; left.leftHeight()) &#123;</span><br><span class="line">                left.leftRotate();</span><br><span class="line">            &#125;</span><br><span class="line">            rightRotate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">midOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            left.midOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            right.midOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="9-9-多路查找树"><a href="#9-9-多路查找树" class="headerlink" title="9.9 多路查找树"></a>9.9 多路查找树</h3><h4 id="1、2-3树"><a href="#1、2-3树" class="headerlink" title="1、2-3树"></a>1、2-3树</h4><ul>
<li><p>2-3 树是最简单的B 树结构,</p>
</li>
<li><p>特点：</p>
<ol>
<li>2-3 树的所有叶子节点都在同一层。(只要是B 树都满足这个条件)</li>
<li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点。</li>
<li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点。</li>
<li>2-3 树是由二节点和三节点构成的树。</li>
</ol>
</li>
<li><p>当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面3 个条件。</p>
</li>
<li><p>对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则。</p>
</li>
</ul>
<h4 id="2、B树、B-树、B-树"><a href="#2、B树、B-树、B-树" class="headerlink" title="2、B树、B+树、B*树"></a>2、B树、B+树、B*树</h4><p><strong>B树</strong></p>
<ul>
<li>B-tree 树即B 树，B 即Balanced，平衡的意思。有人把B-tree 翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B 树又是另一种树。实际上，B-tree 就是指的B 树。</li>
<li>说明：<ol>
<li>B 树的阶：节点的最多子节点个数。比如2-3 树的阶是3，2-3-4 树的阶是4。</li>
<li>B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点。</li>
<li>关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据。</li>
<li>搜索有可能在非叶子结点结束。</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找。</li>
</ol>
</li>
<li>图解：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="http://img.reainyday.top/B%E6%A0%91.jpg"></p>
<p><strong>B+树</strong></p>
<ul>
<li>B+树是B 树的变体，也是一种多路搜索树。</li>
<li>说明：<ol>
<li>B+树的搜索与B 树也基本相同，区别是B+树只有达到叶子结点才命中（B 树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找。</li>
<li>所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。</li>
<li>不可能在非叶子结点命中。</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层。</li>
<li>更适合文件索引系统。</li>
<li>B 树和B+树各有自己的应用场景，不能说B+树完全比B 树好，反之亦然。</li>
</ol>
</li>
<li>图解：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="http://img.reainyday.top/B+%E6%A0%91.jpg"></p>
<p>*<em>B</em>树**</p>
<ul>
<li>B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。</li>
<li>说明：<ol>
<li>B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3，而B+树的块的最低使用率为的1/2。</li>
<li>从第1 个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高。</li>
</ol>
</li>
<li>图解：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="http://img.reainyday.top/B%E6%96%B0%E6%A0%91.jpg"></p>
<h2 id="10、图"><a href="#10、图" class="headerlink" title="10、图"></a>10、图</h2><h3 id="10-1-基本介绍"><a href="#10-1-基本介绍" class="headerlink" title="10.1 基本介绍"></a>10.1 基本介绍</h3><ul>
<li>图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。结点也可以称为顶点。</li>
<li>分类：无向图、有向图、带权图（网）。</li>
<li>图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。</li>
</ul>
<p><strong>邻接矩阵</strong></p>
<ul>
<li>邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n 个顶点的图而言，矩阵是的row 和col 表示的是1….n个点。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="http://img.reainyday.top/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.jpg"></p>
<p><strong>邻接表</strong></p>
<ul>
<li>邻接矩阵需要为每个顶点都分配n 个边的空间，其实有很多边都是不存在,会造成空间的一定损失。</li>
<li>邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="http://img.reainyday.top/%E9%82%BB%E6%8E%A5%E8%A1%A8.jpg"></p>
<h3 id="10-2-图的深度优先搜索（DFS"><a href="#10-2-图的深度优先搜索（DFS" class="headerlink" title="10.2 图的深度优先搜索（DFS)"></a>10.2 图的深度优先搜索（DFS)</h3><p><strong>说明</strong></p>
<ul>
<li>深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。</li>
<li>我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。</li>
<li>深度优先搜索是一个递归的过程。</li>
</ul>
<p><strong>步骤</strong></p>
<ol>
<li>访问初始结点v，并标记结点v 为已访问。</li>
<li>查找结点v 的第一个邻接结点w。</li>
<li>若w 存在，则继续执行4，如果w 不存在，则回到第1 步，将从v 的下一个结点继续。</li>
<li>若w 未被访问，对w 进行深度优先遍历递归（即把w 当做另一个v，然后进行步骤123）。</li>
<li>查找结点v 的w 邻接结点的下一个邻接结点，转到步骤3。</li>
</ol>
<h3 id="10-3-图的广度优先搜索（BFS）"><a href="#10-3-图的广度优先搜索（BFS）" class="headerlink" title="10.3 图的广度优先搜索（BFS）"></a>10.3 图的广度优先搜索（BFS）</h3><ul>
<li>类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点。</li>
</ul>
<p><strong>步骤</strong></p>
<ol>
<li>访问初始结点v 并标记结点v 为已访问。</li>
<li>结点v 入队列。</li>
<li>当队列非空时，继续执行，否则算法结束。</li>
<li>出队列，取得队头结点u。</li>
<li>查找结点u 的第一个邻接结点w。</li>
<li>若结点u 的邻接结点w 不存在，则转到步骤3；否则循环执行以下三个步骤：<ol>
<li>若结点w 尚未被访问，则访问结点w 并标记为已访问。</li>
<li>结点w 入队列。</li>
<li>查找结点u 的继w 邻接结点后的下一个邻接结点w，转到步骤6。</li>
</ol>
</li>
</ol>
<h3 id="10-4-代码实现"><a href="#10-4-代码实现" class="headerlink" title="10.4 代码实现"></a>10.4 代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dreamin.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;<span class="comment">//节点集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges;<span class="comment">//存储图的邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> edgeNum;<span class="comment">//边的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] record;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(<span class="number">4</span>);</span><br><span class="line">        String[] vertexs = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            graph.insertVertex(vertexs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        graph.saveEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.saveEdge(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        graph.saveEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.showGraph();</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;深搜结果：&quot;</span>);</span><br><span class="line">        System.out.print(v + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        graph.dfs(v);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.record.length; i++) &#123;</span><br><span class="line">            graph.record[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;广搜结果：&quot;</span>);</span><br><span class="line">        graph.linkedList.add(v);</span><br><span class="line">        graph.record[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        graph.bfs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深度优先搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        record[v] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getVertexNum(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v][i] &gt; <span class="number">0</span> &amp;&amp; record[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//广度优先搜索</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">if</span> (!linkedList.isEmpty())</span><br><span class="line">            v = linkedList.remove();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(v + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getVertexNum(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v][i] &gt; <span class="number">0</span> &amp;&amp; record[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                linkedList.add(i);</span><br><span class="line">                record[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bfs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//图的初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> ArrayList&lt;String&gt;(n);</span><br><span class="line">        edgeNum = <span class="number">0</span>;</span><br><span class="line">        record = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//图的显示</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : edges) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(row));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertVertex</span><span class="params">(String target)</span> </span>&#123;</span><br><span class="line">        vertexList.add(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveEdge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        edges[i][j] = weight;</span><br><span class="line">        edges[j][i] = weight;</span><br><span class="line">        edgeNum++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结点数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVertexNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回边数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEdgeNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edgeNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回两点权值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>查找</tag>
        <tag>树</tag>
      </tags>
  </entry>
</search>
